# 1.认识微服务

随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？

## 1.0.学习目标

了解微服务架构的优缺点

## 1.1.单体架构

**单体架构**：将业务的所有功能集中在一个项目中开发，打成一个包部署。

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399319282-ad9cb403-1a3a-43a4-a7a6-d1158cc120a2.png#averageHue=%23f9f2f1&id=jt9mD&originHeight=416&originWidth=1203&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

单体架构的优缺点如下：

**优点：**

- 架构简单
- 部署成本低

**缺点：**

- 耦合度高（维护困难、升级困难）

## 1.2.分布式架构

**分布式架构**：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399319503-b4de7c55-890a-49bc-be44-9703423f9a65.png#averageHue=%23f9f6f5&id=Iz4GW&originHeight=701&originWidth=1370&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

分布式架构的优缺点：

**优点：**

- 降低服务耦合
- 有利于服务升级和拓展

**缺点：**

- 服务调用关系错综复杂

分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：

- 服务拆分的粒度如何界定？
- 服务之间如何调用？
- 服务的调用关系如何管理？

人们需要制定一套行之有效的标准来约束分布式架构。

## 1.3.微服务

微服务的架构特征：

- 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责
- 自治：团队独立、技术独立、数据独立，独立部署和交付
- 面向服务：服务提供统一标准的接口，与语言和技术无关
- 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399319671-5a5b6ff4-1d41-4304-96ba-e8f83396d9ea.png#averageHue=%23f9f3f3&id=T7yhU&originHeight=355&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。

因此，可以认为**微服务**是一种经过良好架构设计的**分布式架构方案** 。

但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。

其中在Java领域最引人注目的就是SpringCloud提供的方案了。

## 1.4.SpringCloud

SpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。

SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。

其中常见的组件包括：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399319804-5a676363-3694-420a-96e1-cfd34cb98139.png#averageHue=%23f4f0ef&id=fFFNh&originHeight=573&originWidth=1332&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399319924-86cba23e-e3cf-4607-b5b7-8546d1c88248.png#averageHue=%23fefefd&id=yoptM&originHeight=362&originWidth=885&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。

## 1.5.总结

-  单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统 
-  分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝 
-  微服务：一种良好的分布式架构方案
①优点：拆分粒度更小、服务更独立、耦合度更低
②缺点：架构非常复杂，运维、监控、部署难度提高 
-  SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件 

# 2.服务拆分和远程调用

任何分布式架构都离不开服务的拆分，微服务也是一样。

## 2.1.服务拆分原则

这里我总结了微服务拆分时的几个原则：

- 不同微服务，不要重复开发相同业务
- 微服务数据独立，不要访问其它微服务的数据库
- 微服务可以将自己的业务暴露为接口，供其它微服务调用

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320079-647d4b80-0711-4702-9bd6-152bb93138c4.png#averageHue=%23f8edec&id=ah7V7&originHeight=575&originWidth=1130&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

## 2.2.服务拆分示例

以课前资料中的微服务cloud-demo为例，其结构如下：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320189-49bb5b0b-ae87-4b87-a1e0-f1000eb1b52c.png#averageHue=%23f5f2ee&id=kube0&originHeight=384&originWidth=427&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

cloud-demo：父工程，管理依赖

- order-service：订单微服务，负责订单相关业务
- user-service：用户微服务，负责用户相关业务

要求：

- 订单微服务和用户微服务都必须有各自的数据库，相互独立
- 订单服务和用户服务都对外暴露Restful的接口
- 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库

### 2.2.1.导入Sql语句

首先，将课前资料提供的`cloud-order.sql`和`cloud-user.sql`导入到mysql中：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320334-9ebd3f44-4703-4278-ab4d-13ccfa035476.png#averageHue=%23cbac6e&id=DmGGt&originHeight=210&originWidth=564&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

cloud-user表中初始数据如下：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320436-a838d5bf-7e2c-4882-a3b1-06751e33d298.png#averageHue=%23f2f0ed&id=RV6iD&originHeight=205&originWidth=390&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

cloud-order表中初始数据如下：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320557-d244347f-381a-4a32-9b8a-1e44ee74ac1b.png#averageHue=%23f3f0ed&id=pyQvh&originHeight=256&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

cloud-order表中持有cloud-user表中的id字段。

### 2.2.2.导入demo工程

用IDEA导入课前资料提供的Demo：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320665-cfaac845-94ec-405a-b171-78e3b1eb127b.png#id=JOocq&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

项目结构如下：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320789-a08643fe-76d5-4211-83cf-d39508bea7a3.png#id=Gau1H&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

导入后，会在IDEA右下角出现弹窗：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320891-7b4c6337-3a8c-4b11-9057-a84df013f1be.png#id=fkLDX&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

点击弹窗，然后按下图选择：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399320994-c37c58f3-7c26-4ec2-a310-33150ee4cdef.png#id=i7gyM&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

会出现这样的菜单：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399321109-7e060b1a-2c43-4047-b771-ce08412f1946.png#id=i3dXR&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

配置下项目使用的JDK：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399321206-4926ea1e-6f32-4e8c-a92a-b0b48e7c1ee5.png#id=Cwn7O&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

## 2.3.实现远程调用案例

在order-service服务中，有一个根据id查询订单的接口：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399321311-d96d66ab-17e4-4bfd-ac6e-d4ca23a391fd.png#id=UgDRb&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

根据id查询订单，返回值是Order对象，如图：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399321464-3f8a3157-89ed-4f6d-95a0-ac660700ed49.png#id=daBga&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

其中的user为null

在user-service中有一个根据id查询用户的接口：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399321558-9520c2ce-5385-4e20-9e7d-7a4435735ad3.png#id=sC3fS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

查询的结果如图：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399321659-a2d7062a-0b5b-482a-bbbe-2f0c70321ad6.png#averageHue=%23fcfbfa&id=lUoSU&originHeight=202&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 2.3.1.案例需求：

修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399321775-fd57e680-2efc-4074-b742-0b86450c1a35.png#averageHue=%23f9f3f3&id=CkoAY&originHeight=583&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

因此，我们需要在order-service中 向user-service发起一个http的请求，调用http://localhost:8081/user/{userId}这个接口。

大概的步骤是这样的：

- 注册一个RestTemplate的实例到Spring容器
- 修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User
- 将查询的User填充到Order对象，一起返回

### 2.3.2.注册RestTemplate

首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：

```java
package cn.itcast.order;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@MapperScan("cn.itcast.order.mapper")
@SpringBootApplication
public class OrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

### 2.3.3.实现远程调用

修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399321897-e97ba0e5-e52b-4375-8d80-ebbeab6a87d9.png#averageHue=%23f6faf3&id=WBM3o&originHeight=804&originWidth=1065&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

## 2.4.提供者与消费者

在服务调用关系中，会有两个不同的角色：

**服务提供者**：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）

**服务消费者**：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399322068-8fed033b-6c19-4890-b160-f8c6343db59b.png#averageHue=%23fdfdfd&id=nnLSG&originHeight=180&originWidth=1049&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。

如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？

- 对于A调用B的业务而言：A是服务消费者，B是服务提供者
- 对于B调用C的业务而言：B是服务消费者，C是服务提供者

因此，服务B既可以是服务提供者，也可以是服务消费者。

# 
