---
title: 19-0 多级缓存：概述
urlname: btg6wpsb5fxdldbl
date: '2024-03-31 11:09:09'
updated: '2024-03-31 11:12:24'
cover: ''
description: 笔记来源：黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案什么是多级缓存传统的缓存策略一般是请求到达Tomcat后，笔记来源：黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案什么是多级缓存传统的缓存...
---
**笔记来源：**[**黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案**](https://www.bilibili.com/video/BV1cr4y1671t/?spm_id_from=333.337.search-card.all.click&vd_source=e8046ccbdc793e09a75eb61fe8e84a30)
## 什么是多级缓存
传统的缓存策略一般是请求到达Tomcat后，**笔记来源：**[**黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案**](https://www.bilibili.com/video/BV1cr4y1671t/?spm_id_from=333.337.search-card.all.click&vd_source=e8046ccbdc793e09a75eb61fe8e84a30)
## 什么是多级缓存
传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：
![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307681-a5a8c897-6e69-4127-a20b-d61a663ff0d0.png#averageHue=%23f9f6f6&clientId=ud93c4645-373a-4&id=TEGdN&originHeight=418&originWidth=1153&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6caba6b2-a991-4b45-aae5-96b25deca99&title=)
存在下面的问题：

- 请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈
- Redis缓存失效时，会对数据库产生冲击

多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：

- 浏览器访问静态资源时，优先读取浏览器本地缓存
- 访问非静态资源（ajax查询数据）时，访问服务端
- 请求到达Nginx后，优先读取Nginx本地缓存
- 如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）
- 如果Redis查询未命中，则查询Tomcat
- 请求进入Tomcat后，优先查询JVM进程缓存
- 如果JVM进程缓存未命中，则查询数据库

![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307641-a34d1205-92b1-41ed-9187-22d4a27c529a.png#averageHue=%23f6f4f2&clientId=ud93c4645-373a-4&id=y7nie&originHeight=495&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6a264703-35f4-4bd7-9bcd-edc5157ab31&title=)
在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个**反向代理服务器**，而是一个编写**业务的Web服务器了**。
因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：
![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307673-b2da5667-b299-4b18-8dfc-512ee69330d6.png#averageHue=%23f7f6f4&clientId=ud93c4645-373a-4&id=XqNBo&originHeight=555&originWidth=1547&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uefb6835e-5e09-44ae-afb0-ea2fa16a995&title=)
另外，我们的Tomcat服务将来也会部署为集群模式：
![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307632-fb27fc87-da38-4cc7-b054-8cf7fe766e73.png#averageHue=%23f6f5f3&clientId=ud93c4645-373a-4&id=vyBKX&originHeight=496&originWidth=1550&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua4a3ee6a-12e9-4953-97da-9e5a75be478&title=)

可见，多级缓存的关键有两个：

- 一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询
- 另一个就是在Tomcat中实现JVM进程缓存

其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。先查询Redis，如果未命中则查询数据库，如图：
![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307681-a5a8c897-6e69-4127-a20b-d61a663ff0d0.png#averageHue=%23f9f6f6&clientId=ud93c4645-373a-4&id=L0yEX&originHeight=418&originWidth=1153&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6caba6b2-a991-4b45-aae5-96b25deca99&title=)
存在下面的问题：

- 请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈
- Redis缓存失效时，会对数据库产生冲击

多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：

- 浏览器访问静态资源时，优先读取浏览器本地缓存
- 访问非静态资源（ajax查询数据）时，访问服务端
- 请求到达Nginx后，优先读取Nginx本地缓存
- 如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）
- 如果Redis查询未命中，则查询Tomcat
- 请求进入Tomcat后，优先查询JVM进程缓存
- 如果JVM进程缓存未命中，则查询数据库

![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307641-a34d1205-92b1-41ed-9187-22d4a27c529a.png#averageHue=%23f6f4f2&clientId=ud93c4645-373a-4&id=TO6iL&originHeight=495&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6a264703-35f4-4bd7-9bcd-edc5157ab31&title=)
在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个**反向代理服务器**，而是一个编写**业务的Web服务器了**。
因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：
![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307673-b2da5667-b299-4b18-8dfc-512ee69330d6.png#averageHue=%23f7f6f4&clientId=ud93c4645-373a-4&id=stt3X&originHeight=555&originWidth=1547&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uefb6835e-5e09-44ae-afb0-ea2fa16a995&title=)
另外，我们的Tomcat服务将来也会部署为集群模式：
![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307632-fb27fc87-da38-4cc7-b054-8cf7fe766e73.png#averageHue=%23f6f5f3&clientId=ud93c4645-373a-4&id=uzv9g&originHeight=496&originWidth=1550&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua4a3ee6a-12e9-4953-97da-9e5a75be478&title=)

可见，多级缓存的关键有两个：

- 一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询
- 另一个就是在Tomcat中实现JVM进程缓存

其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。
**笔记来源：**[**黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案**](https://www.bilibili.com/video/BV1cr4y1671t/?spm_id_from=333.337.search-card.all.click&vd_source=e8046ccbdc793e09a75eb61fe8e84a30)
## 1 初识Caffeine
缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：

-  分布式缓存，例如Redis： 
   - 优点：存储容量更大、可靠性更好、可以在集群间共享
   - 缺点：访问缓存有网络开销
   - 场景：缓存数据量较大、可靠性要求较高、需要在集群间共享
-  进程本地缓存，例如HashMap、GuavaCache： 
   - 优点：读取本地内存，没有网络开销，速度更快
   - 缺点：存储容量有限、可靠性较低、无法共享
   - 场景：性能要求较高，缓存数据量较小

我们今天会利用Caffeine框架来实现JVM进程缓存。
**Caffeine**是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：[https://github.com/ben-manes/caffeine](https://github.com/ben-manes/caffeine)
Caffeine的性能非常好，下图是官方给出的性能对比：
![](https://cdn.nlark.com/yuque/0/2022/png/22334924/1665042307619-034dd193-a382-4cb1-9adf-f52dd39eff60.png#averageHue=%23f6f5f4&clientId=ud93c4645-373a-4&id=ewptu&originHeight=434&originWidth=876&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucb6ae82e-1308-415d-8d65-1353a1c6645&title=)
可以看到Caffeine的性能遥遥领先！

缓存使用的基本API：
```java
@Test
void testBasicOps() {
    // 构建cache对象
    Cache<String, String> cache = Caffeine.newBuilder().build();

    // 存数据
    cache.put("gf", "迪丽热巴");

    // 取数据
    String gf = cache.getIfPresent("gf");
    System.out.println("gf = " + gf);

    // 取数据，包含两个参数：
    // 参数一：缓存的key
    // 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑
    // 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式
    String defaultGF = cache.get("defaultGF", key -> {
        // 根据key去数据库查询数据
        return "柳岩";
    });
    System.out.println("defaultGF = " + defaultGF);
}
```
Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。
Caffeine提供了三种缓存驱逐策略：

-  **基于容量**：设置缓存的数量上限 
```java
// 创建缓存对象
Cache<String, String> cache = Caffeine.newBuilder()
    .maximumSize(1) // 设置缓存大小上限为 1
    .build();
```
 

-  **基于时间**：设置缓存的有效时间 
```java
// 创建缓存对象
Cache<String, String> cache = Caffeine.newBuilder()
    // 设置缓存有效期为 10 秒，从最后一次写入开始计时 
    .expireAfterWrite(Duration.ofSeconds(10)) 
    .build();
```

-  **基于引用**：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。 

> **注意**：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。


## 2 实现JVM进程缓存
### 2.1 需求
利用Caffeine实现下列需求：

- 给根据id查询商品的业务添加缓存，缓存未命中时查询数据库
- 给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库
- 缓存初始大小为100
- 缓存上限为10000
### 2.2 实现
首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。
在item-service的`com.heima.item.config`包下定义`CaffeineConfig`类：
```java
package com.heima.item.config;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.heima.item.pojo.Item;
import com.heima.item.pojo.ItemStock;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CaffeineConfig {

    @Bean
    public Cache<Long, Item> itemCache(){
        return Caffeine.newBuilder()
                .initialCapacity(100)
                .maximumSize(10_000)
                .build();
    }

    @Bean
    public Cache<Long, ItemStock> stockCache(){
        return Caffeine.newBuilder()
                .initialCapacity(100)
                .maximumSize(10_000)
                .build();
    }
}
```
然后，修改item-service中的`com.heima.item.web`包下的ItemController类，添加缓存逻辑：
```java
@RestController
@RequestMapping("item")
public class ItemController {

    @Autowired
    private IItemService itemService;
    @Autowired
    private IItemStockService stockService;

    @Autowired
    private Cache<Long, Item> itemCache;
    @Autowired
    private Cache<Long, ItemStock> stockCache;
    
    // ...其它略
    
    @GetMapping("/{id}")
    public Item findById(@PathVariable("id") Long id) {
        return itemCache.get(id, key -> itemService.query()
                .ne("status", 3).eq("id", key)
                .one()
        );
    }

    @GetMapping("/stock/{id}")
    public ItemStock findStockById(@PathVariable("id") Long id) {
        return stockCache.get(id, key -> stockService.getById(key));
    }
}
```

