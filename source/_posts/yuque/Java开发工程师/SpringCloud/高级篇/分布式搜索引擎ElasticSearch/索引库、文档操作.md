> 在前面读者朋友们可以了解到ES承载着和MySQL一样的“存储-查询”功能，那么就类似的会有建表语句、表结构、表数据，有了这些才可以存储-查询数据。而这些对应的在ES中是：Mapping映射（表结构-建表语句）、索引库（表本身）、文档（表数据）。本节笔者将带领大家完整上述概念的创建、使用。

# 1.es的一些概念
elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。
## 1.1.文档和字段
elasticsearch是面向**文档（Document）**存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：<br />![image-20210720202707797.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877065127-60c2b69a-cdf1-4bed-aab4-eb1e6d16c350.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f0eaea&clientId=u53a3a557-8479-4&from=paste&height=372&id=ub664a9d5&originHeight=558&originWidth=1357&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=53254&status=done&style=none&taskId=u55d55e35-ee63-44fe-a39b-4eaee0037e8&title=&width=904.6666666666666)<br />而Json文档中往往包含很多的**字段（Field）**，类似于数据库中的列。
## 1.2.索引和映射
**索引（Index）**，就是相同类型的文档的集合。例如：

- 所有用户文档，就可以组织在一起，称为用户的索引；
- 所有商品的文档，可以组织在一起，称为商品的索引；
- 所有订单的文档，可以组织在一起，称为订单的索引；

因此，我们可以把索引当做是数据库中的表。<br />数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有**映射（mapping）**，是索引中文档的字段约束信息，类似表的结构约束。<br />![image-20210720203022172.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877091091-08599a14-c501-4e32-9bf0-622166a14f8b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_42%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f7f1ec&clientId=u53a3a557-8479-4&from=paste&height=388&id=u16a72e25&originHeight=582&originWidth=1483&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=72866&status=done&style=none&taskId=ua2f80ef7-3d61-4ac2-8160-62df703f444&title=&width=988.6666666666666)
## 1.3.mysql与elasticsearch
我们统一的把mysql与elasticsearch的概念做一下对比：

| **MySQL** | **Elasticsearch** | **说明** |
| --- | --- | --- |
| Table | Index | 索引(index)，就是文档的集合，类似数据库的表(table) |
| Row | Document | 文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式 |
| Column | Field | 字段（Field），就是JSON文档中的字段，类似数据库中的列（Column） |
| Schema | Mapping | Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema） |
| SQL | DSL | DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD |

是不是说，我们学习了elasticsearch就不再需要mysql了呢？并不是如此，两者各自有自己的擅长支出：

-  Mysql：擅长事务类型操作，可以确保数据的安全和一致性 
-  Elasticsearch：擅长海量数据的搜索、分析、计算 

因此在企业中，往往是两者结合使用：

- 对安全性要求较高的写操作，使用mysql实现
- 对查询性能要求较高的搜索需求，使用elasticsearch实现
- 两者再基于某种方式，实现数据的同步，保证一致性

![image-20210720203534945.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877176888-8fd15791-e4bd-499f-b6e6-e92b72e9e409.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23fdfdfd&clientId=u53a3a557-8479-4&from=paste&height=231&id=ucadeb0f1&originHeight=347&originWidth=959&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=34589&status=done&style=none&taskId=u0f2bb97f-edce-4660-8c81-ae2660dd0a4&title=&width=639.3333333333334)
## 1.4.安装es、kibana
### 1.4.1.安装
参考：[链接](https://www.yuque.com/xiankanpengyouquandisitiaodongtai/diods0/gg8zrm9xpu3vhgrx)
### 1.4.2.分词器
参考：[链接](https://www.yuque.com/xiankanpengyouquandisitiaodongtai/diods0/gg8zrm9xpu3vhgrx)
### 1.4.3.总结
分词器的作用是什么？

- 创建倒排索引时对文档分词
- 用户搜索时，对输入的内容分词

IK分词器有几种模式？

- ik_smart：智能切分，粗粒度
- ik_max_word：最细切分，细粒度

IK分词器如何拓展词条？如何停用词条？

- 利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典
- 在词典中添加拓展词条或者停用词条
# 2.索引库操作
索引库就类似数据库表，mapping映射就类似表的结构。我们要向es中存储数据，必须先创建“库”和“表”。
## 2.1.mapping映射属性
mapping是对索引库中文档的约束，常见的mapping属性包括：

- type：字段数据类型，常见的简单类型有： 
   - 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）
   - 数值：long、integer、short、byte、double、float、
   - 布尔：boolean
   - 日期：date
   - 对象：object
- index：是否创建索引，默认为true
- analyzer：使用哪种分词器
- properties：该字段的子字段

例如下面的json文档：
```json
{
    "age": 21,
    "weight": 52.1,
    "isMarried": false,
    "info": "黑马程序员Java讲师",
    "email": "zy@itcast.cn",
    "score": [99.1, 99.5, 98.9],
    "name": {
        "firstName": "云",
        "lastName": "赵"
    }
}
```
对应的每个字段映射（mapping）：

- age：类型为 integer；参与搜索，因此需要index为true；无需分词器
- weight：类型为float；参与搜索，因此需要index为true；无需分词器
- isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器
- info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart
- email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器
- score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器
- name：类型为object，需要定义多个子属性 
   - name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器
   - name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器
## 2.2.索引库的CRUD
这里我们统一使用Kibana编写DSL的方式来演示。
### 2.2.1.创建索引库和映射
#### 基本语法：

- 请求方式：PUT
- 请求路径：/索引库名，可以自定义
- 请求参数：mapping映射

格式：
```json
PUT /索引库名称
{
  "mappings": {
    "properties": {
      "字段名":{
        "type": "text",
        "analyzer": "ik_smart"
      },
      "字段名2":{
        "type": "keyword",
        "index": "false"
      },
      "字段名3":{
        "properties": {
          "子字段": {
            "type": "keyword"
          }
        }
      },
      // ...略
    }
  }
}
```
#### 示例：
```shell
PUT /heima
{
  "mappings": {
    "properties": {
      "info":{
        "type": "text",
        "analyzer": "ik_smart"
      },
      "email":{
        "type": "keyword",
        "index": "false"
      },
      "name":{
        "properties": {
          "firstName": {
            "type": "keyword"
          }
        }
      },
      // ... 略
    }
  }
}
```
### 2.2.2.查询索引库
**基本语法**：

-  请求方式：GET 
-  请求路径：/索引库名 
-  请求参数：无 

**格式**：
```
GET /索引库名
```
**示例**：<br />![image-20210720211019329.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877270614-d0033427-992a-4447-b545-da9b62b60071.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f5f8fb&clientId=u53a3a557-8479-4&from=paste&height=329&id=u86eea8c6&originHeight=494&originWidth=876&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=133746&status=done&style=none&taskId=ueceac75b-3405-43ef-b672-b58e721787f&title=&width=584)
### 2.2.3.修改索引库
倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库**一旦创建，无法修改mapping**。虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。<br />**语法说明**：
```json
PUT /索引库名/_mapping
{
  "properties": {
    "新字段名":{
      "type": "integer"
    }
  }
}
```
**示例**：<br />![image-20210720212357390.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877295729-c9a5fdce-2d30-4555-927f-4c6bbc9210cc.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_30%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23eff3f8&clientId=u53a3a557-8479-4&from=paste&height=161&id=uec0680a6&originHeight=242&originWidth=1036&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=73048&status=done&style=none&taskId=u591a0711-bdd1-467b-9a6f-ec12a5f2785&title=&width=690.6666666666666)
### 2.2.4.删除索引库
**语法：**

-  请求方式：DELETE 
-  请求路径：/索引库名 
-  请求参数：无 

**格式：**
```
DELETE /索引库名
```
在kibana中测试：<br />![image-20210720212123420.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877316625-21763ba0-9062-408d-83dc-c43d461eb97f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f3f6fa&clientId=u53a3a557-8479-4&from=paste&height=127&id=u16f24eb4&originHeight=191&originWidth=1164&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=56007&status=done&style=none&taskId=u93c249b5-1213-4fc9-a61b-812af326e29&title=&width=776)
### 2.2.5.总结
索引库操作有哪些？

- 创建索引库：PUT /索引库名
- 查询索引库：GET /索引库名
- 删除索引库：DELETE /索引库名
- 添加字段：PUT /索引库名/_mapping
# 3.文档操作
## 3.1.新增文档
**语法：**
```json
POST /索引库名/_doc/文档id
{
    "字段1": "值1",
    "字段2": "值2",
    "字段3": {
        "子属性1": "值3",
        "子属性2": "值4"
    },
    // ...
}
```
**示例：**
```json
POST /heima/_doc/1
{
    "info": "黑马程序员Java讲师",
    "email": "zy@itcast.cn",
    "name": {
        "firstName": "云",
        "lastName": "赵"
    }
}
```
**响应：**<br />![image-20210720212933362.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877342267-b69a3077-3e29-4067-81e9-99b48816835e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f0f4f9&clientId=u53a3a557-8479-4&from=paste&height=233&id=uae74d56c&originHeight=350&originWidth=960&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=137887&status=done&style=none&taskId=ucde7f836-628b-402d-a01f-5597c866de2&title=&width=640)<br />针对同一个index，其中version在每次写操作后都会+1（新增、修改、删除）<br />![ES文档新增没有age.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1680594739536-f362ae37-caf5-4499-9f36-1f641c317903.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_38%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23e5eef5&clientId=ub6a9cbca-c07a-4&from=paste&height=339&id=u83c56c45&originHeight=509&originWidth=1346&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=96708&status=done&style=none&taskId=uf389a63b-c3e4-4fc8-ae24-3960fcd6f87&title=&width=897.3333333333334)<br />![ES文档新增有age（字段非空都返回）.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1680594745447-fafa8da1-187f-487e-831c-cca99dc338a4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23eef3f7&clientId=ub6a9cbca-c07a-4&from=paste&height=357&id=u7ba1d386&originHeight=535&originWidth=1204&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=90176&status=done&style=none&taskId=ud8c3815c-58a6-46c4-81d4-1596f0b9607&title=&width=802.6666666666666)
## 3.2.查询文档
根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。<br />**语法：**
```json
GET /{索引库名称}/_doc/{id}
```
**通过kibana查看数据：**
```javascript
GET /heima/_doc/1
```
**查看结果：**<br />![image-20210720213345003.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877361303-6b4f43a7-7a11-4629-ab2b-c5e62a7b80ce.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f6f9fc&clientId=u53a3a557-8479-4&from=paste&height=279&id=uf59a3c5a&originHeight=418&originWidth=1207&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=118191&status=done&style=none&taskId=ud51733fb-838a-40d0-bca6-3c8fe1e8aa5&title=&width=804.6666666666666)
## 3.3.删除文档
删除使用DELETE请求，同样，需要根据id进行删除：<br />**语法：**
```javascript
DELETE /{索引库名}/_doc/id值
```
**示例：**
```json
# 根据id删除数据
DELETE /heima/_doc/1
```
**结果：**<br />![image-20210720213634918.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877382935-68fd2c9c-c3a2-4387-9881-b1c26cd9a9ae.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f6f9fc&clientId=u53a3a557-8479-4&from=paste&height=225&id=u8fe2c1b8&originHeight=338&originWidth=1031&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=92884&status=done&style=none&taskId=ua6fc262f-57a6-480c-a053-fdbfa1e51ec&title=&width=687.3333333333334)
## 3.4.修改文档
修改有两种方式：

- 全量修改：直接覆盖原来的文档
- 增量修改：修改文档中的部分字段
### 3.4.1.全量修改
全量修改是覆盖原来的文档，其本质是：

- 根据指定的id删除文档
- 新增一个相同id的文档

**注意**：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。<br />**语法：**
```json
PUT /{索引库名}/_doc/文档id
{
    "字段1": "值1",
    "字段2": "值2",
    // ... 略
}
```
**示例：**
```json
PUT /heima/_doc/1
{
    "info": "黑马程序员高级Java讲师",
    "email": "zy@itcast.cn",
    "name": {
        "firstName": "云",
        "lastName": "赵"
    }
}
```
### 3.4.2.增量修改
增量修改是只修改指定id匹配的文档中的部分字段。<br />**语法：**
```json
POST /{索引库名}/_update/文档id
{
    "doc": {
         "字段名": "新的值",
    }
}
```
**示例：**
```json
POST /heima/_update/1
{
  "doc": {
    "email": "ZhaoYun@itcast.cn"
  }
}
```
## 3.5.总结
文档操作有哪些？

- 创建文档：POST /{索引库名}/_doc/文档id   { json文档 }
- 查询文档：GET /{索引库名}/_doc/文档id
- 删除文档：DELETE /{索引库名}/_doc/文档id
- 修改文档： 
   - 全量修改：PUT /{索引库名}/_doc/文档id { json文档 }
   - 增量修改：POST /{索引库名}/_update/文档id { "doc": {字段}}
# 4.RestAPI
ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：[https://www.elastic.co/guide/en/elasticsearch/client/index.html](https://www.elastic.co/guide/en/elasticsearch/client/index.html)<br />其中的Java Rest Client又包括两种：

- Java Low Level Rest Client
- Java High Level Rest Client

我们学习的是Java HighLevel Rest Client客户端API
## 4.0.导入Demo工程
### 4.0.1.导入数据
首先导入提供的数据库数据：[tb_hotel.sql](https://www.yuque.com/attachments/yuque/0/2024/sql/29688613/1711614903531-7a2ee938-36be-47e9-9379-a015f45b6172.sql?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2024%2Fsql%2F29688613%2F1711614903531-7a2ee938-36be-47e9-9379-a015f45b6172.sql%22%2C%22name%22%3A%22tb_hotel.sql%22%2C%22size%22%3A63466%2C%22ext%22%3A%22sql%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uc6aade0d-dd98-42b2-b1fa-fe2ec80ae5a%22%2C%22taskType%22%3A%22transfer%22%2C%22type%22%3A%22%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u9fd34a4b%22%2C%22card%22%3A%22file%22%7D)<br />数据结构如下：
```sql
CREATE TABLE `tb_hotel` (
  `id` bigint(20) NOT NULL COMMENT '酒店id',
  `name` varchar(255) NOT NULL COMMENT '酒店名称；例：7天酒店',
  `address` varchar(255) NOT NULL COMMENT '酒店地址；例：航头路',
  `price` int(10) NOT NULL COMMENT '酒店价格；例：329',
  `score` int(2) NOT NULL COMMENT '酒店评分；例：45，就是4.5分',
  `brand` varchar(32) NOT NULL COMMENT '酒店品牌；例：如家',
  `city` varchar(32) NOT NULL COMMENT '所在城市；例：上海',
  `star_name` varchar(16) DEFAULT NULL COMMENT '酒店星级，从低到高分别是：1星到5星，1钻到5钻',
  `business` varchar(255) DEFAULT NULL COMMENT '商圈；例：虹桥',
  `latitude` varchar(32) NOT NULL COMMENT '纬度；例：31.2497',
  `longitude` varchar(32) NOT NULL COMMENT '经度；例：120.3925',
  `pic` varchar(255) DEFAULT NULL COMMENT '酒店图片；例:/img/1.jpg',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```
### 4.0.2.导入项目
然后导入提供的项目:[hotel-demo.zip](https://www.yuque.com/attachments/yuque/0/2024/zip/29688613/1711614903525-936ab2b4-eafe-4df9-b119-7da4523612b1.zip?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2024%2Fzip%2F29688613%2F1711614903525-936ab2b4-eafe-4df9-b119-7da4523612b1.zip%22%2C%22name%22%3A%22hotel-demo.zip%22%2C%22size%22%3A135519%2C%22ext%22%3A%22zip%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u8acfbb99-e6d8-47a5-b802-966c75ed214%22%2C%22taskType%22%3A%22transfer%22%2C%22type%22%3A%22application%2Fx-zip-compressed%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u1f25e66e%22%2C%22card%22%3A%22file%22%7D)<br />项目结构如图：<br />![image-20210720220647541.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877482138-214197ed-6ee5-4070-834f-bdcd54d9010e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_37%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f2f8ef&clientId=u53a3a557-8479-4&from=paste&height=393&id=u0870f732&originHeight=590&originWidth=1311&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=396907&status=done&style=none&taskId=u0d4ad2ad-27de-45b5-9cd7-45a4be480f0&title=&width=874)
### 4.0.3.mapping映射分析
创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：

- 字段名
- 字段数据类型
- 是否参与搜索
- 是否需要分词
- 如果分词，分词器是什么？

其中：

- 字段名、字段数据类型，可以参考数据表结构的名称和类型
- 是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索
- 是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词
- 分词器，我们可以统一使用ik_max_word

来看下酒店数据的索引库结构:
```json
PUT /hotel
{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword"
      },
      "name":{
        "type": "text",
        "analyzer": "ik_max_word",
        "copy_to": "all"
      },
      "address":{
        "type": "keyword",
        "index": false
      },
      "price":{
        "type": "integer"
      },
      "score":{
        "type": "integer"
      },
      "brand":{
        "type": "keyword",
        "copy_to": "all"
      },
      "city":{
        "type": "keyword",
        "copy_to": "all"
      },
      "starName":{
        "type": "keyword"
      },
      "business":{
        "type": "keyword"
      },
      "location":{
        "type": "geo_point"
      },
      "pic":{
        "type": "keyword",
        "index": false
      },
      "all":{
        "type": "text",
        "analyzer": "ik_max_word"
      }
    }
  }
}
```
几个特殊字段说明：

- location：地理坐标，里面包含精度、纬度
- all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索

地理坐标说明：<br />![image-20210720222110126.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877504709-a5b92bdf-3ef7-4b23-8eb9-80f670ad347a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_40%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f4f2f2&clientId=u53a3a557-8479-4&from=paste&height=155&id=u2eef2bf3&originHeight=233&originWidth=1413&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=36396&status=done&style=none&taskId=u6de457b3-d52f-4b51-b95d-7d32d9cb8ca&title=&width=942)<br />copy_to说明：<br />![](assets/image-20210720222221516.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_9%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#id=WBweb&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
### 4.0.4.初始化RestClient
#### 方式一
在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。<br />分为三步：<br />1）引入es的RestHighLevelClient依赖：
```xml
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
</dependency>
```
2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：
```xml
<properties>
    <java.version>1.8</java.version>
    <elasticsearch.version>7.12.1</elasticsearch.version>
</properties>
```
3）启动类初始化RestHighLevelClient，初始化的代码如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1684297022764-013fd00a-b83d-46e9-824f-b66d86152bd3.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_38%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23fdfcfa&clientId=u5dc50c56-d22c-4&from=paste&height=309&id=u909b433f&originHeight=464&originWidth=1342&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=55723&status=done&style=none&taskId=ud6cbe47a-b2e6-4747-92fc-8ffdc486248&title=&width=894.6666666666666)<br />4）引入
```java
package cn.itcast.hotel;

import org.apache.http.HttpHost;
import org.apache.http.client.methods.HttpPost;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestClientBuilder;
import org.elasticsearch.client.RestHighLevelClient;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import javax.annotation.Resource;
import java.io.IOException;

@SpringBootTest
public class HotelIndexTest {

    @Resource
    private RestHighLevelClient client;

    @Test
    public void testInit() {
        System.out.println(this.client);
    }

}

```
#### 方式二
可以直接在单测类完整创建、初始化
```java
package cn.itcast.hotel;

import org.apache.http.HttpHost;
import org.apache.http.client.methods.HttpPost;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestClientBuilder;
import org.elasticsearch.client.RestHighLevelClient;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;

@SpringBootTest
public class HotelIndexTest {

    private RestHighLevelClient client;

    @BeforeEach
    void setUp() {
        this.client = new RestHighLevelClient(RestClient.builder(
                HttpHost.create("http://192.168.150.101:9200/")
        ));
    }

    @Test
    public void testInit() {
        System.out.println(this.client);
    }

    @AfterEach
    void tearDown() throws IOException {
        this.client.close();
    }
}

```
## 4.1.创建索引库
### 4.1.1.代码解读
创建索引库的API如下：<br />![image-20210720223049408.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877554052-823ed37f-9add-40e9-ba2d-4f8dab9bc9c8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23e8efe4&clientId=u53a3a557-8479-4&from=paste&height=505&id=ub6f8c7d0&originHeight=757&originWidth=1426&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=218819&status=done&style=none&taskId=uf993f438-b508-46cd-bf67-9ee6bbef370&title=&width=950.6666666666666)<br />代码分为三步：

- 1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。
- 2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。
- 3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。
### 4.1.2.完整示例
在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：
```java
package cn.itcast.hotel.constants;

public class HotelConstants {
    public static final String MAPPING_TEMPLATE = "{\n" +
            "  \"mappings\": {\n" +
            "    \"properties\": {\n" +
            "      \"id\": {\n" +
            "        \"type\": \"keyword\"\n" +
            "      },\n" +
            "      \"name\":{\n" +
            "        \"type\": \"text\",\n" +
            "        \"analyzer\": \"ik_max_word\",\n" +
            "        \"copy_to\": \"all\"\n" +
            "      },\n" +
            "      \"address\":{\n" +
            "        \"type\": \"keyword\",\n" +
            "        \"index\": false\n" +
            "      },\n" +
            "      \"price\":{\n" +
            "        \"type\": \"integer\"\n" +
            "      },\n" +
            "      \"score\":{\n" +
            "        \"type\": \"integer\"\n" +
            "      },\n" +
            "      \"brand\":{\n" +
            "        \"type\": \"keyword\",\n" +
            "        \"copy_to\": \"all\"\n" +
            "      },\n" +
            "      \"city\":{\n" +
            "        \"type\": \"keyword\",\n" +
            "        \"copy_to\": \"all\"\n" +
            "      },\n" +
            "      \"starName\":{\n" +
            "        \"type\": \"keyword\"\n" +
            "      },\n" +
            "      \"business\":{\n" +
            "        \"type\": \"keyword\"\n" +
            "      },\n" +
            "      \"location\":{\n" +
            "        \"type\": \"geo_point\"\n" +
            "      },\n" +
            "      \"pic\":{\n" +
            "        \"type\": \"keyword\",\n" +
            "        \"index\": false\n" +
            "      },\n" +
            "      \"all\":{\n" +
            "        \"type\": \"text\",\n" +
            "        \"analyzer\": \"ik_max_word\"\n" +
            "      }\n" +
            "    }\n" +
            "  }\n" +
            "}";
}
```
在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：
```java
@Test
void createHotelIndex() throws IOException {
    // 1.创建Request对象
    CreateIndexRequest request = new CreateIndexRequest("hotel");
    // 2.准备请求的参数：DSL语句
    request.source(MAPPING_TEMPLATE, XContentType.JSON);
    // 3.发送请求
    client.indices().create(request, RequestOptions.DEFAULT);
}
```
## 4.2.删除索引库
删除索引库的DSL语句非常简单：
```json
DELETE /hotel
```
与创建索引库相比：

- 请求方式从PUT变为DELTE
- 请求路径不变
- 无请求参数

所以代码的差异，注意体现在Request对象上。依然是三步走：

- 1）创建Request对象。这次是DeleteIndexRequest对象
- 2）准备参数。这里是无参
- 3）发送请求。改用delete方法

在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：
```java
@Test
void testDeleteHotelIndex() throws IOException {
    // 1.创建Request对象
    DeleteIndexRequest request = new DeleteIndexRequest("hotel");
    // 2.发送请求
    client.indices().delete(request, RequestOptions.DEFAULT);
}
```
## 4.3.判断索引库是否存在
判断索引库是否存在，本质就是查询，对应的DSL是：
```json
GET /hotel
```
因此与删除的Java代码流程是类似的。依然是三步走：

- 1）创建Request对象。这次是GetIndexRequest对象
- 2）准备参数。这里是无参
- 3）发送请求。改用exists方法
```java
@Test
void testExistsHotelIndex() throws IOException {
    // 1.创建Request对象
    GetIndexRequest request = new GetIndexRequest("hotel");
    // 2.发送请求
    boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);
    // 3.输出
    System.err.println(exists ? "索引库已经存在！" : "索引库不存在！");
}
```
## 4.4.总结
JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。<br />索引库操作的基本步骤：

- 初始化RestHighLevelClient
- 创建XxxIndexRequest。XXX是Create、Get、Delete
- 准备DSL（ Create时需要，其它是无参）
- 发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete
# 5.RestClient操作文档
为了与索引库操作分离，我们再次参加一个测试类，做两件事情：

- 初始化RestHighLevelClient
- 我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口
```java
package cn.itcast.hotel;

import cn.itcast.hotel.pojo.Hotel;
import cn.itcast.hotel.service.IHotelService;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;
import java.util.List;

@SpringBootTest
public class HotelDocumentTest {
    @Autowired
    private IHotelService hotelService;

    private RestHighLevelClient client;

    @BeforeEach
    void setUp() {
        this.client = new RestHighLevelClient(RestClient.builder(
                HttpHost.create("http://192.168.150.101:9200")
        ));
    }

    @AfterEach
    void tearDown() throws IOException {
        this.client.close();
    }
}
```
## 5.1.新增文档
我们要将数据库的酒店数据查询出来，写入elasticsearch中。
### 5.1.1.索引库实体类
数据库查询后的结果是一个Hotel类型的对象。结构如下：
```java
@Data
@TableName("tb_hotel")
public class Hotel {
    @TableId(type = IdType.INPUT)
    private Long id;
    private String name;
    private String address;
    private Integer price;
    private Integer score;
    private String brand;
    private String city;
    private String starName;
    private String business;
    private String longitude;
    private String latitude;
    private String pic;
}
```
与我们的索引库结构存在差异：

- longitude和latitude需要合并为location

因此，我们需要定义一个新的类型，与索引库结构吻合：
```java
package cn.itcast.hotel.pojo;

import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class HotelDoc {
    private Long id;
    private String name;
    private String address;
    private Integer price;
    private Integer score;
    private String brand;
    private String city;
    private String starName;
    private String business;
    private String location;
    private String pic;

    public HotelDoc(Hotel hotel) {
        this.id = hotel.getId();
        this.name = hotel.getName();
        this.address = hotel.getAddress();
        this.price = hotel.getPrice();
        this.score = hotel.getScore();
        this.brand = hotel.getBrand();
        this.city = hotel.getCity();
        this.starName = hotel.getStarName();
        this.business = hotel.getBusiness();
        this.location = hotel.getLatitude() + ", " + hotel.getLongitude();
        this.pic = hotel.getPic();
    }
}
```
### 5.1.2.语法说明
新增文档的DSL语句如下：
```json
POST /{索引库名}/_doc/1
{
    "name": "Jack",
    "age": 21
}
```
对应的java代码如图<br />![image-20210720230027240.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877626761-b7d4bcfd-a153-4e26-b07c-a1caceca0c7b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_43%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23e9f1e5&clientId=u53a3a557-8479-4&from=paste&height=265&id=u9d247b55&originHeight=397&originWidth=1494&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=96635&status=done&style=none&taskId=ue1693e73-f7c2-4464-adf6-50194ec0d32&title=&width=996)<br />可以看到与创建索引库类似，同样是三步走：

- 1）创建Request对象
- 2）准备请求参数，也就是DSL中的JSON文档
- 3）发送请求

变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。
### 5.1.3.完整代码
我们导入酒店数据，基本流程一致，但是需要考虑几点变化：

- 酒店数据来自于数据库，我们需要先查询出来，得到hotel对象
- hotel对象需要转为HotelDoc对象
- HotelDoc需要序列化为json格式

因此，代码整体步骤如下：

- 1）根据id查询酒店数据Hotel
- 2）将Hotel封装为HotelDoc
- 3）将HotelDoc序列化为JSON
- 4）创建IndexRequest，指定索引库名和id
- 5）准备请求参数，也就是JSON文档
- 6）发送请求

在hotel-demo的HotelDocumentTest测试类中，编写单元测试：
```java
@Test
void testAddDocument() throws IOException {
    // 1.根据id查询酒店数据
    Hotel hotel = hotelService.getById(61083L);
    // 2.转换为文档类型
    HotelDoc hotelDoc = new HotelDoc(hotel);
    // 3.将HotelDoc转json
    String json = JSON.toJSONString(hotelDoc);

    // 1.准备Request对象
    IndexRequest request = new IndexRequest("hotel").id(hotelDoc.getId().toString());
    // 2.准备Json文档
    request.source(json, XContentType.JSON);
    // 3.发送请求
    client.index(request, RequestOptions.DEFAULT);
}
```
## 5.2.查询文档
### 5.2.1.语法说明
查询的DSL语句如下：
```json
GET /hotel/_doc/{id}
```
非常简单，因此代码大概分两步：

- 准备Request对象
- 发送请求

不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：<br />![image-20210720230811674.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877654614-3e30ade3-c80e-41a4-961d-65fe8758d9a6.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23eaf1e6&clientId=u53a3a557-8479-4&from=paste&height=351&id=ub930049c&originHeight=526&originWidth=1424&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=132970&status=done&style=none&taskId=u4afeb295-d10d-46b1-9c00-0bc88c18dab&title=&width=949.3333333333334)可以看到，结果是一个JSON，其中文档放在一个`_source`属性中，因此解析就是拿到`_source`，反序列化为Java对象即可。<br />与之前类似，也是三步走：

- 1）准备Request对象。这次是查询，所以是GetRequest
- 2）发送请求，得到结果。因为是查询，这里调用client.get()方法
- 3）解析结果，就是对JSON做反序列化
### 5.2.2.完整代码
在hotel-demo的HotelDocumentTest测试类中，编写单元测试：
```java
@Test
void testGetDocumentById() throws IOException {
    // 1.准备Request
    GetRequest request = new GetRequest("hotel", "61082");
    // 2.发送请求，得到响应
    GetResponse response = client.get(request, RequestOptions.DEFAULT);
    // 3.解析响应结果
    String json = response.getSourceAsString();

    HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);
    System.out.println(hotelDoc);
}
```
## 5.3.删除文档
删除的DSL为是这样的：
```json
DELETE /hotel/_doc/{id}
```
与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走：

- 1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id
- 2）准备参数，无参
- 3）发送请求。因为是删除，所以是client.delete()方法

在hotel-demo的HotelDocumentTest测试类中，编写单元测试：
```java
@Test
void testDeleteDocument() throws IOException {
    // 1.准备Request
    DeleteRequest request = new DeleteRequest("hotel", "61083");
    // 2.发送请求
    client.delete(request, RequestOptions.DEFAULT);
}
```
## 5.4.修改文档
### 5.4.1.语法说明
修改我们讲过两种方式：

- 全量修改：本质是先根据id删除，再新增
- 增量修改：修改文档中的指定字段值

在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：

- 如果新增时，ID已经存在，则修改
- 如果新增时，ID不存在，则新增

这里不再赘述，我们主要关注增量修改。<br />代码示例如图：<br />![image-20210720231040875.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877688127-ea761c6b-f3cb-4def-b0af-01a0e00abc84.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23eaf2e6&clientId=u53a3a557-8479-4&from=paste&height=306&id=u0c0aafe2&originHeight=459&originWidth=1365&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=96922&status=done&style=none&taskId=u157b523d-1763-4f39-b892-5e4251f7360&title=&width=910)<br />![](assets/image-20210720231040875.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_9%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#id=FpjOR&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

- 1）准备Request对象。这次是修改，所以是UpdateRequest
- 2）准备参数。也就是JSON文档，里面包含要修改的字段
- 3）更新文档。这里调用client.update()方法
### 5.4.2.完整代码
在hotel-demo的HotelDocumentTest测试类中，编写单元测试：
```java
@Test
void testUpdateDocument() throws IOException {
    // 1.准备Request
    UpdateRequest request = new UpdateRequest("hotel", "61083");
    // 2.准备请求参数
    request.doc(
        "price", "952",
        "starName", "四钻"
    );
    // 3.发送请求
    client.update(request, RequestOptions.DEFAULT);
}
```
## 5.5.批量导入文档
案例需求：利用BulkRequest批量将数据库数据导入到索引库中。<br />步骤如下：

-  利用mybatis-plus查询酒店数据 
-  将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc） 
-  利用JavaRestClient中的BulkRequest批处理，实现批量新增文档 
### 5.5.1.语法说明
批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。其中提供了一个add方法，用来添加其他请求：<br />![image-20210720232105943.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877714933-1ae53e10-2d78-4067-96c2-9576a0666e75.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f5f3f1&clientId=u53a3a557-8479-4&from=paste&height=207&id=u0443a2ce&originHeight=311&originWidth=795&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=30226&status=done&style=none&taskId=u738ac306-fdfa-4670-9bd9-0007ced435e&title=&width=530)<br />可以看到，能添加的请求包括：

- IndexRequest，也就是新增
- UpdateRequest，也就是修改
- DeleteRequest，也就是删除

因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：<br />![image-20210720232431383.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1678877723434-bb007df6-7600-41ed-a936-1e6f1798b679.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_30%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23e9f1e5&clientId=u53a3a557-8479-4&from=paste&height=265&id=u3a0865d4&originHeight=397&originWidth=1049&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=76886&status=done&style=none&taskId=ud79e1385-560d-4682-9954-3961104d283&title=&width=699.3333333333334)<br />其实还是三步走：

- 1）创建Request对象。这里是BulkRequest
- 2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest
- 3）发起请求。这里是批处理，调用的方法为client.bulk()方法

我们在导入酒店数据时，将上述代码改造成for循环处理即可。
### 5.5.2.完整代码
在hotel-demo的HotelDocumentTest测试类中，编写单元测试：
```java
@Test
void testBulkRequest() throws IOException {
    // 批量查询酒店数据
    List<Hotel> hotels = hotelService.list();

    // 1.创建Request
    BulkRequest request = new BulkRequest();
    // 2.准备参数，添加多个新增的Request
    for (Hotel hotel : hotels) {
        // 2.1.转换为文档类型HotelDoc
        HotelDoc hotelDoc = new HotelDoc(hotel);
        // 2.2.创建新增文档的Request对象
        request.add(new IndexRequest("hotel")
                    .id(hotelDoc.getId().toString())
                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));
    }
    // 3.发送请求
    client.bulk(request, RequestOptions.DEFAULT);
}
```
通过指令查询：GET /hotel/_search<br />![数据批量导入验证结果.png](https://cdn.nlark.com/yuque/0/2023/png/1169676/1680594716663-9a3fd567-adea-4361-8d99-e593d08512a5.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_45%2Ctext_5rK554K45bCP5rOi%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f0f4f7&clientId=ub6a9cbca-c07a-4&from=paste&height=419&id=ud7565461&originHeight=629&originWidth=1587&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=107294&status=done&style=none&taskId=ucee0a55e-9c9c-43ab-bd67-6740ab4d020&title=&width=1058)
## 5.6.小结
文档操作的基本步骤：

- 初始化RestHighLevelClient
- 创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk
- 准备参数（Index、Update、Bulk时需要）
- 发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk
- 解析结果（Get时需要）
