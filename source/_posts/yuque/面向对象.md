Java的个人笔记需要不断的更新和迭代，简短的看菜鸟教程，或者尚硅谷文档
# 面向对象
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241933600.png&sign=cab639ca297afdd7410034496511ce55c86fe9baf8a32e5bd0df6cd95d8392d0#from=url&id=bEkvm&originHeight=4834&originWidth=1943&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241940422.png&sign=7cd6926ba0783daa7385196942e004cf420b0914c52306b4f6c7f290153da1ef#from=url&id=Bdf2L&originHeight=3952&originWidth=2120&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946073.png&sign=a7a22ab5f41064090066d60a8e597e15f17eb1814e72ac45cdb9323b640026d1#from=url&id=MJRA5&originHeight=4972&originWidth=2136&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
## 问答环节
15.⾯向对象和⾯向过程的区别?
16.面向对象有哪些特性
17.重载（overload）和重写（override）的区别？
18.访问修饰符 public、private、protected、以及不写（默认）时的区别？
19.this 关键字有什么作用？
20.抽象类(abstract class)和接口(interface)有什么区别？
21.成员变量与局部变量的区别有哪些？
22.静态变量和实例变量的区别？静态方法、实例方法呢？
24.final 关键字有什么作用？
25.final、finally、finalize 的区别？
26.==和 equals 的区别？
27.hashCode 与 equals?
28.Java 是值传递，还是引用传递？
29.深拷贝和浅拷贝?
30.Java 创建对象有哪几种方式？
## 类和对象
### 概述
**1、什么是类**
**类**：具有相同特征的事物的抽象描述，是抽象的、概念上的定义。
**2、什么是对象**
**对象**：实际存在的该类事物的每个个体，是具体的，因而也称为实例(instance)。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241933993.png#clientId=u80adf2f2-205b-4&from=url&id=c1WIn&originHeight=294&originWidth=705&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u88907ec5-6a6b-4f99-b833-c19b10ce4ba&title=)
### 类的成员概述
面向对象程序设计的重点是类的设计
类的设计，其实就是类的成员的设计

- 类，是一组相关属性和行为的集合，这也是类最基本的两个成员。
   - **属性**：该类事物的状态信息。对应类中的成员变量
      - **成员变量 <=> 属性 <=> Field**
   - **行为**：该类事物要做什么操作，或者基于事物的状态能做什么。对应类中的成员方法
      - **(成员)方法 <=> 函数 <=> Method**
### 面向对象完成功能三步骤
步骤1：类的定义
类的定义使用关键字：class。格式如下：
```
[修饰符] class 类名{
	属性声明;
    方法声明;
}
```
举例1：
```
public class Person{
    //声明属性age
    int age ;	                   
    
    //声明方法showAge()
    public void eat() {        
	    System.out.println("人吃饭");
    }
}
```
举例2：
```
public class Dog{
    //声明属性
	String type; //种类
	String nickName; //昵称
	String hostName; //主人名称
	
    //声明方法
	public void eat(){ //吃东西
		System.out.println("狗狗进食");		
	}
}
```
步骤2：对象的创建
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241933000.png&sign=f30a9eef78307f8af87467dde525632940a7a6e277ea241410847eea634b1425#from=url&id=dtxKl&originHeight=419&originWidth=898&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
创建对象，使用关键字：new
创建对象语法：
举例：
步骤3：对象调用属性或方法
对象是类的一个实例，必然具备该类事物的属性和行为（即方法）。
使用"对象名.属性" 或 "对象名.方法"的方式访问对象成员（包括属性和方法）
举例1：
```
//声明Animal类
public class Animal { //动物类
    public int legs;

    public void eat() {
        System.out.println("Eating.");
    }

    public void move() {
        System.out.println("Move.");
    }
}
```
### 匿名对象
● 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。
  ○ 如：new Person().shout();
● 使用情况
  ○ 如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象。
  ○ 我们经常将匿名对象作为实参传递给一个方法调用。

### 对象的内存解析* 
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241928815.png&sign=c733ca6a95aa4f4af6cfc28090ccd6de7acd40f04f37df34923688230d7e2d4c#from=url&id=oG152&originHeight=573&originWidth=670&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29688613/1664521790633-0d3355c4-77d9-46ac-8a45-9fb1724f40bf.png#averageHue=%23f3f2f2&clientId=u3d00b6b5-0ff9-4&from=paste&height=521&id=vnZbG&originHeight=646&originWidth=1546&originalType=binary&ratio=1&rotation=0&showTitle=false&size=212380&status=done&style=none&taskId=u70ebcab8-11ee-4428-8871-64270874633&title=&width=1247.1932373305492)

| 区域名称 | 作用 |
| --- | --- |
| 虚拟机栈 | 用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度
的各种基本数据类型、对象引用，方法执行完，自动释放。 |
| 堆内存 | 存储对象（包括数组对象），new来创建的，都存储在堆内存。 |
| 方法区 | 存储已被虚拟机加载的类信息、常量、（静态变量）、即时编译器编译后的代码等数据。 |
| 本地方法栈 | 当程序中调用了native的本地方法时，本地方法执行期间的内存区域 |
| 程序计数器 | 程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址 |

1.方法区最先有数据，因为类最先被加载，主要存储静态变量， 代码片段
2.栈的活动最频繁，方法调用压栈，该方法需要内存在栈中分配，栈中最主要存储局部变量。局部变量是在方法当中的。
3.凡是通过new创建的对象，都存储在堆内存当中。new运算发的作用就是在堆内存中开辟一块空间。对象存储在堆内存当中。堆内存中存储对象，以及对象的实例变量。
4.栈：方法只要执行，就会压栈，（局部变量）
5.堆：new出来的对象都在堆中。垃圾回收器主要针对。（实例变量）
6.方法区：类的信息，字节码信息，代码片段。（静态变量）

成员变量没有手动赋值时，系统默认赋值。赋的值都是默认值。
实例变量在访问的时候，是不是必须先创建对象？ 不是
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29688613/1664522745433-8cf66c32-4b81-4adf-9f99-a186be9c9562.png#averageHue=%23f2f1eb&clientId=u3d00b6b5-0ff9-4&from=paste&height=478&id=ehu4L&originHeight=592&originWidth=1578&originalType=binary&ratio=1&rotation=0&showTitle=false&size=474006&status=done&style=none&taskId=uf8b799c8-9dda-41cb-9d4b-ddce898d219&title=&width=1273.0083625534326)

### 对象和引用的区别
对象是new出来的，在堆内存中存储。
引用是凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。
### 对象数组
**数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，我们称为对象数组。**
```
Student[] students = new Student[20];
		// 通过循环结构给数组的属性赋值
		for (int i = 0; i < students.length; i++) {
			// 数组元素的赋值
			students[i] = new Student();
			// 数组元素是一个对象，给对象的各个属性赋值
			students[i].number = (i + 1);
			students[i].state = (int) (Math.random() * 6 + 1);// [1,6]
			students[i].score = (int) (Math.random() * 101);// [0,100]
		}

		// 问题一：打印出3年级(state值为3）的学生信息。
		for (int i = 0; i < students.length; i++) {

			if (students[i].state == 3) {
//				System.out.println(
//						"number:" + students[i].number + ",state:" + students[i].state + ",score:" + students[i].score);
				students[i].info();
				
			}

		}
		System.out.println("******************************");
```

## 类的成员之一：成员变量*
如何访问实例变量
引用.实例变量名。
成员变量
1：成员变量：部分所定义的变量被称为类的成员变量。也就是说成员变量在整个类中都有效，类中的方法可以直接调用成员变量使用。
然而成员变量又分为实例成员变量（简称实例变量）和类变量（简称静态变量）
2：局部变量：在方法体中定义的变量和方法的参数称局部变量。也就是说局部变量只在定义它的方法内有效，而方法外部的其他方法无法使用局部变量。当局部变量名字与成员变量名字相同，则成员变量被隐藏，即这个成员变量在这个方法内暂时失效，以局部变量定义的为准。
成员变量：包括实例变量和类变量
成员方法：包括实例方法和类方法
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241933006.png&sign=0b5897eb5c29dfdb846d0173af066ae9391faabd85ff72e12dc50811d7a313c9#from=url&id=d7RUX&originHeight=319&originWidth=848&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
类方法（静态方法）：static关键字修饰的方法
静态方法（类方法）只能访问静态成员，静态方法，不能够访问非静态成员，非静态方法
非静态方法（实例方法）既可以访问非静态成员，非静态方法，还可以访问静态成员，静态方法
静态方法和非静态方法的区别（调用方法不同）
静态方法可以直接调用，类名调用和对象调用。（类名.方法名 / 对象名.方法名）
但是非静态方法只能通过对象调用。（对象名.方法名）
**声明位置和方式**
**实例变量：在类中方法外**
**局部变量: 在方法体或方法的形参列表，代码块中**
**在内存中的存储位置不同**
**（1）实例变量：堆
（2）局部变量：栈**
**3、生命周期
（1）实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被GC回收而消亡，
而且每一个对象的实例变量是独立的。
（2）局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随着方法执行的结束而消亡，
而且每一次方法调用都是独立。**
**4、作用域**
**（1）实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量”**
**（2）局部变量：出了作用域就不能使用**
**5、修饰符（后面来讲）**
**（1）实例变量：public,protected,private,final,volatile,transient等**
**（2）局部变量：final**
**6、默认值**
**（1）实例变量：有默认值**
**（2）局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化。**

## 类的成员之二方法
### 使用注意
1.必须先声明再使用，且方法必须定义在类内部
2.调用一次就执行一次，不调用不执行
3.方法中可以调用类中的方法或属性，不可以在方法内部定义方法
### 方法调用内存分析
方法在没有被调用的时候，都是在方法区中的字节码文件中存储
方法被调用的时候，需要进入到栈内存中运行。方法每调用一次就会在栈中有一个入栈动作，即给当前方法开辟一块独立的内存区域，用于存储当前方法的局部变量的值
当方法执行结束后，会释放该内存，称为出栈，如果方法中有返回值，就会把结果返回调用处，如果没有返回值，就直接结束，回到调用处继续执行下一条指令。
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241933012.png&sign=ad6f36dc5272d462edd78d5fed63695450f3cb5a9b4a44ac0ab84b11138466fb#from=url&id=ckjo3&originHeight=586&originWidth=1214&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
### 练习
要求：
(1)创建Person类的对象，设置该对象的name、age和sex属性，调用study方法，输出字符串“studying”，调用showAge()方法显示age值，调用addAge()方法给对象的age属性值增加2岁。
(2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。
**练习2：**利用面向对象的编程方法，设计圆类Circle，包含属性（半径）和计算圆面积的方法。定义测试类，创建该Circle类的对象，并进行测试。
**练习3：**
3.1 编写程序，声明一个method方法，在方法中打印一个10*8的*型矩形，在main方法中调用该方法。
3.2 修改上一个程序，在method方法中，除打印一个10*8的*型矩形外，再计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。
3.3 修改上一个程序，在method方法提供m和n两个参数，方法中打印一个m*n的*型矩形，并计算该矩形的面积， 将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。
**练习4：**声明一个日期类型MyDate：有属性：年year,月month，日day。创建2个日期对象，分别赋值为：你的出生日期，你对象的出生日期，并显示信息。
**练习5（课下练习）：**用面向对象的方式编写用户登录程序。
用户类：

- 属性：用户名，密码
- 方法：登录

界面类：

- 在界面类中添加main方法，接受用户输入，并调用用户类的登录方法进行验证。 
   - 输出： 
      - 登录失败：用户名或密码错误！
      - 登录成功：欢迎你，用户名！
### 方法重载
● 方法重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。 
  ○ 参数列表不同，意味着参数个数或参数类型的不同
● 重载的特点：与修饰符、返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。
● 重载方法调用：JVM通过方法的参数列表，调用匹配的方法。 
  ○ 先找个数、类型最匹配的
  ○ 再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错
### 可变个数的形参
在JDK 5.0 中提供了Varargs(variable number of arguments)机制。即当定义一个方法时，形参的类型可以确定，但是形参的个数不确定，那么可以考虑使用可变个数的形参。
```
//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量
public static void test(int a ,String[] books);

//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量
public static void test(int a ,String...books);
```
特点：
可变参数:方法参数部分的指定类型的参数个数是可变的
可变个数参数的方法与同名方法之间，彼此构成重载
可变参数方法的使用与方法参数部分使用数组是一致的，二者不能同时声明，否则报错
在一个方法的形参中，最多只能声明一个可变个数的形参
### 递归(recursion)方法
递归方法调用:方法自己调用自己的现象叫做递归
递归的分类：直接递归，间接递归

- 直接递归：方法自身调用自己。
```
public void methodA(){
	methodA();
}
```

- 间接递归：可以理解为A()方法调用B()方法，B()方法调用C()方法，C()方法调用A()方法。
```
public static void A(){
	B();
}

public static void B(){
	C();
}

public static void C(){
	A();
}
```
说明:
递归是一种隐式的循环
递归方法会重复执行某段代码，但这种重复执行无须循环控制
递归一定要向已知方向递归，否则这种递归编程无穷递归，停不下来
举例
```
public class RecursionDemo {
public static void main(String[] args) {
 RecursionDemo demo = new RecursionDemo();
//计算 1~num 的和，使用递归完成
int num = 5;
 // 调用求和的方法
int sum = demo.getSum(num);
 // 输出结果
System.out.println(sum);
}
 /*
 通过递归算法实现.
 参数列表:int 
 返回值类型: int 
 */
public int getSum(int num) {
 /* 
 num 为 1 时,方法返回 1,
 相当于是方法的出口,num 总有是 1 的情况
 */
if(num == 1){
return 1;
}
 /*
 num 不为 1 时,方法返回 num +(num-1)的累和
 递归调用 getSum 方法
 */
return num + getSum(num-1);
}
}
```
代码图解
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710138238438-7ccfeb1c-2d56-4eaf-ba0a-5b57706a7e51.png#averageHue=%23c3c3c2&clientId=u80adf2f2-205b-4&from=paste&height=335&id=QHxSN&originHeight=415&originWidth=695&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=153940&status=done&style=none&taskId=uc5393f44-99a4-426d-a994-1797b1f39a0&title=&width=560.6722509344967)
递归方法计算n!
```
public int multiply(int num){
  if(num == 1){
    return 1;
  }else{
    return num * multiply(num - 1);
  }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710138368583-f08b7b3e-31ad-4c4d-bb8a-53444e573a45.png#averageHue=%23c5c3c3&clientId=u80adf2f2-205b-4&from=paste&height=265&id=CnhGY&originHeight=329&originWidth=614&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48213&status=done&style=none&taskId=u420786e6-07da-4652-87d1-77e0cb35635&title=&width=495.3277152140733)
递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时要比循环慢，所以在使用递归时要慎重
## 类的成员之三：构造器
new 对象，并在对象的时候实例变量赋值
举例：Person p = new Person(“Peter”,15);
解释：如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器
中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序
就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。
### 语法
[修饰符] **class **类名{ 
[修饰符] 构造器名(){ 
_// 实例初始化代码 _
} 
[修饰符] 构造器名(参数列表){ 
_// 实例初始化代码 _
} 
} 
说明： 
31. 构造器名必须与它所在的类名必须相同。 
32. 它没有返回值，所以不需要返回值类型，也不需要 void。 
33. 构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被 static、 
final、synchronized、abstract、native 修饰，不能有 return 语句返回值。
在我们没有显式的声明类中的构造器时，系统会默认提供一个无参的构造器并且该构造器的修饰符默认与类的修饰符相同 
User user = new User();
2.属性赋值
```

class Person
{
	private String name;					//声明姓名属性
	private int age;						//声明年龄属性
	public Person(String name,int age)		//定义构造方法为属性初始化
	{
		this.setName(name);					//为name属性赋值
		this.setAge(age);					//为age属性赋值
	}
	public void tell()						//取得信息的方法
	{
		System.out.println("姓名：" + getName() + "，年龄：" + getAge());
	}
	public String getName()					//取得姓名
	{
		return name;
	}
	public void setName(String n)			//设置姓名
	{
		name = n;
	}
	public int getAge()						//取得年龄
	{
		return age;
	}
	public void setAge(int a)				//设置年龄
	{
		if(a >= 0 && a < 150)				//在此处加上验证代码
		{
			age = a;
		}
	}	
}
public class ConsDemo02
{
	public static void main(String args())
	{
		Person per = new person("张三"，30);	//调用构造结构方法，传递两个参数
		per.tell();							//输出信息
	}
```
缺省构造方法：如果自己不写，系统默认给你一个缺省构造方法
空指针异常导致的最本质的原因是:
空引用访问“实例相关的数据”，会出现空指针异常
静态方法不需要new对象，直接使用类名.来访问
但是也可以使用“引用.”来访问，不建议用。 （因为其它程序员会感到有困惑。
st.dosome()代码最终执行的时候还是会转变为：StaticTest04.doSome()
Java创建类的构造方法，new是调用类的构造方法
1.new关键字创建的时候：
默认化化初始值
调用类中的构造方法
Object object = new Object(参数)中的参数就是调用构造方法中有实参的方法 　若是调用无参的是没有参数的
## 类的成员之四：代码块
### 静态代码块
#### 特点
类加载时执行，并且只执行一次
静态代码块有这样的特征/特点。
静态代码块在类加载时执行，并且在main方法执行之前执行
静态代码块一般是按照从上而下的顺序执行
静态代码块有啥作用？
1.静态代码块不是那么常用。
2.静态代码块这种语法机制实际上是sun公司给我们Java程序员的一个特殊时刻/时机
这个时机/时刻叫做：类加载时机
具体的业务：
项目经理说了：我们编写的程序中，只要是类加载了， 请记录一下类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了），
这些记录日志的代码写哪里区
写到静态代码块中。

### 实例代码块(非静态代码块)
#### 语法格式
```java
【修饰符】 class 类{
    {
        非静态代码块
    }
    【修饰符】 构造器名(){
    	// 实例初始化代码
    }
    【修饰符】 构造器名(参数列表){
        // 实例初始化代码
    }
}
```

只要是构造方法执行，必然在构造方法执行之前，自动执行”实例额语句块“中的代码。
实际上是SUN公司为Java程序员准备的一个特殊时机，叫做对象构建时机
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29688613/1664530413467-0338c73a-4d2b-4134-928c-c2741ee8043c.png#averageHue=%23232330&clientId=u3d00b6b5-0ff9-4&from=paste&height=642&id=U60af&originHeight=796&originWidth=860&originalType=binary&ratio=1&rotation=0&showTitle=false&size=110010&status=done&style=none&taskId=uc3260ba2-4f33-4d94-8750-d8d2b7d9dfa&title=&width=693.7814903649886)
如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。
#### 特点

1. 可以有输出语句。
2. 可以对类的属性、类的声明进行初始化操作。
3. 除了调用非静态的结构外，还可以调用静态的变量或方法。
4. 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。
5. 每次创建对象的时候，都会执行一次。且先于构造器执行。
### 代码执行顺序
1.对于一个方法来说，方法体中的代码时有顺序的，遵循自上而下的顺序执行
2.静态代码块1和静态代码块2是有先后顺序的
3.静态代码块和静态变量是有先后顺序的。
父类静态成员变量，父类静态代码块，子类的静态成员变量，子类静态代码块，父类非静态成员变量，父类非静态代码块，父类构造函数，子类非静态成员变量，子类非静态代码块，子类构造函数
## 封装
把一个东西，装到箱子里只留一个小口，用于外界访问
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29688613/1664615200642-7bcb7f2c-60a1-4fba-9343-c6935558d19e.png#averageHue=%23f6f6f6&clientId=ub09bc86d-353f-4&from=paste&id=WmmQT&originHeight=483&originWidth=821&originalType=url&ratio=1&rotation=0&showTitle=false&size=20335&status=done&style=none&taskId=uc200fad7-0eb9-461e-a590-ce393ab7f94&title=)
我们在程序设计的过程中“高内聚，低耦合”。高内聚就是类内部数据操作细节自己来完成，不允许外部干涉，低耦合：仅仅暴露少量代码给外部使用。
### 成员变量/属性私有化
概述：私有化类的成员变量，提供公共的 get 和 set 方法，对外暴露获取和修
改属性的功能。
**成员变量封装的好处： **
让使用者只能通过事先预定的方法来_访问数据_，从而可以在该方法里面加入控制逻 
辑，限制对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息 
的完整性。 
_便于修改_，提高代码的可维护性。主要说的是隐藏的部分，在内部修改了，如果其对 
外可以的访问方式不变的话，外部根本感觉不到它的修改。例如：Java8->Java9，String 从 char[]转为 byte[]内部实现，而对外的方法不变，我们使用者根本感觉不到它 
内部的修改。
### 私有化方法
```
private void swap(int[] arr,int i,int j){
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
/**
*
* @param arr
* @param value
* @return 返回 value 值出现的位置 或 -1：未找到
*/
public int getValue(int[] arr, int value) {
  //方法：线性查找
  for(int i = 0;i < arr.length;i++){
  if(value == arr[i]){
  return i;
}

```
开发中，一般成员变量都习惯使用private修饰，再提供相应的public权限的get/set方法访问
对于final的实例变量，不提供set()方法。
对于static final 的成员的变量，习惯上使用public修饰

## 继承

### 继承的特性
子类继承父类的特征和行为，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有相同的行为
继承的出现减少了代码冗余，提高了代码的复用性。 
继承的出现，更有利于功能的扩展。 
继承的出现让类与类之间产生了 _is-a _的关系，为多态的使用提供了前提。–
继承描述事物之间的所属关系，这种关系是：_is-a _的关系。可见，父类更通用、更一般，子类更具体。 
注意：不要仅为了获取其他类中某个功能而去继承。
### 继承的细节说明
**1.子类会继承父类所有的实例变量和实例方法 **
从类的定义来看，类是一类具有相同特性的事物的抽象描述。父类是所有子类 
共同特征的抽象描述。而实例变量和实例方法就是事物的特征，那么父类中声 
明的实例变量和实例方法代表子类事物也有这个特征。 

当子类对象被创建时，在堆中给对象申请内存时，就要看子类和父类都声明了什么实 
例变量，这些实例变量都要分配内存。 

当子类对象调用方法时，编译器会先在子类模板中看该类是否有这个方法，如果没找 
到，会看它的父类甚至父类的父类是否声明了这个方法，遵循_从下往上_找的顺序，找 
到了就停止，一直到根父类都没有找到，就会报编译错误。
2.**子类不能直接访问父类中私有的(private)的成员变量和方法 **
子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量 
直接进行访问，可通过继承的 get/set 方法进行访问。如图所示：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710141061685-f895bc7b-7b72-4832-bd22-f838583a46aa.png#averageHue=%23bdbbba&clientId=u80adf2f2-205b-4&from=paste&height=321&id=obXeW&originHeight=398&originWidth=1081&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=142916&status=done&style=none&taskId=u35be6cd0-7f96-4171-92ed-4efad2de14a&title=&width=872.0671989355264)
3.在Java中，继承用的关键字是"extend",即子类不是父类的子集，而是对父类的"扩展"
子类在继承父类以后，还可以定义自己特有的方法，这就可以看做是对父类功 
能上的扩展。
4.Java支持多层继承
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710141158135-666d2ea1-f19a-4081-802a-1c1ea489a112.png#averageHue=%23c8c5c0&clientId=u80adf2f2-205b-4&from=paste&height=440&id=jrTRj&originHeight=545&originWidth=1145&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=76338&status=done&style=none&taskId=u0adcf4b7-b1b6-41f2-abde-137e3edd6ae&title=&width=923.697449381293)
5.一个父类可以拥有多个子类
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710141209635-c719774d-5872-47b3-b7be-fe0d692ed0c0.png#averageHue=%23c7c6c5&clientId=u80adf2f2-205b-4&from=paste&height=140&id=BqOQc&originHeight=173&originWidth=407&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=20077&status=done&style=none&taskId=u391e1c80-f81a-4295-9b42-2e7bb0fdedc&title=&width=328.33612392854695)
6.Java只支持单继承，不支持多继承
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710141241420-ea44e529-973d-4f79-99b6-a66e923d5124.png#averageHue=%23c4c3c2&clientId=u80adf2f2-205b-4&from=paste&height=429&id=cwHjp&originHeight=532&originWidth=1010&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=82265&status=done&style=none&taskId=u05c84f28-e8e1-4300-adf1-2bacbed0c4d&title=&width=814.7898898472541)
## 多态
### 多态的形式和体现
多种形态，多种状态。 多态性，是面向对象中最重要的概念，在Java中体现：对象多态性：**父类引用指向子类的对象 （父类类型：指子类继承的父类类型，或者实现的接口类型）**
### 多态的理解
Java程序分为编译阶段和运行阶段
编译阶段
对于编译器来收，编译器只知道a2的类型是Animal
所以编译器在检查语法的时候，回去Animal.class
字节码文件中找move()方法，找到了，绑定上move（）
方法，编译通过，静态绑定成功。（编译阶段属于静态绑定）
运行阶段
运行阶段时候，实际上在堆内存中创建Java对象是Cat对象，所以
move的时候，真正参与move的对象是一只猫，所以运行阶段会动态执行Cat对象
的move()方法，这个过程属性运行阶段的绑定（运行阶段绑定属于动态绑定）
动态表示多种形态：
编译的时候是一种形态，
运行的时候是另一种形态。
多态指的是：
父类型引用指向子类型对象。
包括编译阶段和运行阶段
编译阶段：绑定父类的方法。
运行阶段：动态绑定子类型对象的方法。
Java中只有“类名”或者“引用”才能去“点”
类名.
引用.
只要，你想要.,点前面要么是一个类名，要么是一个引用。
System.out中，out后面没有小括号，说明out是一个静态变量
System.out返回的是一个对象，然后采用“对象.”的方式访问println（）方法。
```
static Student stu = new Student();


   Test.stu.exam() ==>            Student s = Test.stu;
                							    s.exam();

```
system.out.println
system是类名
outs是静态变量
对象.println()

```
    public static void main(String[] args) {
        Animal a1 = new Animal();
        a1.move();
        Cat c1 = new Cat();
        c1.move();
        Bird b1 = new Bird();
        b1.move();
        // 父类型的引用允许指向子类型的对象这就叫向上转型
        // a2就是父类型的引用。
        // 向上转型 子===》父 自动类型转换
        // 向下转型 父===》子 强制类型转换
        // 无论是向上还是向下转型，两种类型之间必须要有继承关系，这是首要条件
        // 没有继承关系，就没有向上和向下转型
        // 以后工作中和别人的聊天要专业一点，不能说自动类型转换，也不要说强制类型转换
        // 因为自动类型转换和强制类型转换是使用在基本数据类型方面。
        // 在引用类型方面只有向上和向下。
        Animal a2 = new Cat();
    }
```
什么时候必须使用“向下转型”？
不要随便做强制类型转换。
当你当问的是子类对象中“特有”的方法。此时必须进行向下转型。
Animal a5 = new Cat();
Cat x = (Cat)a5;
x.carchMouse();
因为a5是Animal类型，转成Cat,Animal和Cat之间存在继承关系，所以没报错。
运行是出现异常，这个异常和空指针异常一样非常重要，也非常经典：
java.lang.ClassCastException	类型转换异常。
java.lang.NullPointerException 空指针异常
多态使用的前提：1.类的继承关系2.方法的重写
#### 举例
```
package com.atguigu.polymorphism.grammar;

public class Pet {
    private String nickname; //昵称

    public String getNickname() {
        return nickname;
    }

    public void setNickname(String nickname) {
        this.nickname = nickname;
    }

    public void eat(){
        System.out.println(nickname + "吃东西");
    }
}
```
```
package com.atguigu.polymorphism.grammar;

public class Cat extends Pet {
    //子类重写父类的方法
    @Override
    public void eat() {
        System.out.println("猫咪" + getNickname() + "吃鱼仔");
    }

    //子类扩展的方法
    public void catchMouse() {
        System.out.println("抓老鼠");
    }
}
```
```
package com.atguigu.polymorphism.grammar;

public class Dog extends Pet {
    //子类重写父类的方法
    @Override
    public void eat() {
        System.out.println("狗子" + getNickname() + "啃骨头");
    }

    //子类扩展的方法
    public void watchHouse() {
        System.out.println("看家");
    }
}
```
1.方法内局部变量的赋值体现多态
```
package com.atguigu.polymorphism.grammar;

public class TestPet {
    public static void main(String[] args) {
        //多态引用
        Pet pet = new Dog();
        pet.setNickname("小白");

        //多态的表现形式
        /*
        编译时看父类：只能调用父类声明的方法，不能调用子类扩展的方法；
        运行时，看“子类”，如果子类重写了方法，一定是执行子类重写的方法体；
         */
        pet.eat();//运行时执行子类Dog重写的方法
//      pet.watchHouse();//不能调用Dog子类扩展的方法

        pet = new Cat();
        pet.setNickname("雪球");
        pet.eat();//运行时执行子类Cat重写的方法
    }
}
```
方法的形参声明体现多态
```
package com.atguigu.polymorphism.grammar;

public class Person{
    private Pet pet;
    public void adopt(Pet pet) {//形参是父类类型，实参是子类对象
        this.pet = pet;
    }
    public void feed(){
        pet.eat();//pet实际引用的对象类型不同，执行的eat方法也不同
    }
}
```
```
package com.atguigu.polymorphism.grammar;

public class TestPerson {
    public static void main(String[] args) {
        Person person = new Person();

        Dog dog = new Dog();
        dog.setNickname("小白");
        person.adopt(dog);//实参是dog子类对象，形参是父类Pet类型
        person.feed();

        Cat cat = new Cat();
        cat.setNickname("雪球");
        person.adopt(cat);//实参是cat子类对象，形参是父类Pet类型
        person.feed();
    }
}
```
方法返回值类型体现多态
```
package com.atguigu.polymorphism.grammar;

public class PetShop {
    //返回值类型是父类类型，实际返回的是子类对象
    public Pet sale(String type){
        switch (type){
            case "Dog":
                return new Dog();
            case "Cat":
                return new Cat();
        }
        return null;
    }
}
```
```
package com.atguigu.polymorphism.grammar;

public class TestPetShop {
    public static void main(String[] args) {
        PetShop shop = new PetShop();

        Pet dog = shop.sale("Dog");
        dog.setNickname("小白");
        dog.eat();

        Pet cat = shop.sale("Cat");
        cat.setNickname("雪球");
        cat.eat();
    }
}
```
### 为什么需要多态性(polymorphism)
开发中，有时我们在设计一个数组、或一个成员变量、或一个方法的形参、返回值类型时，无法确定它具体的类型，只能确定它是某个系列的类型。
案例：
（1）声明一个Dog类，包含public void eat()方法，输出“狗啃骨头”
（2）声明一个Cat类，包含public void eat()方法，输出“猫吃鱼仔”
（3）声明一个Person类，功能如下：

- 包含宠物属性
- 包含领养宠物方法 public void adopt(宠物类型Pet)
- 包含喂宠物吃东西的方法 public void feed()，实现为调用宠物对象.eat()方法
```
public class Dog {
    public void eat(){
        System.out.println("狗啃骨头");
    }
}
```
```
public class Cat {
    public void eat(){
        System.out.println("猫吃鱼仔");
    }
}
```
```
public class Person {
    private Dog dog;

    //adopt：领养
    public void adopt(Dog dog){
        this.dog = dog;
    }

    //feed：喂食
    public void feed(){
        if(dog != null){
            dog.eat();
        }
    }
    /*
    问题：
    1、从养狗切换到养猫怎么办？   
    	修改代码把Dog修改为养猫？
    2、或者有的人养狗，有的人养猫怎么办？  
    3、要是还有更多其他宠物类型怎么办？
    如果Java不支持多态，那么上面的问题将会非常麻烦，代码维护起来很难，扩展性很差。
    */
}
```
### 多态的好处和弊端
**好处**：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。
**弊端**：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。
```
Student m = new Student();
m.school = "pku"; 	//合法,Student类有school成员变量
Person e = new Student(); 
e.school = "pku";	//非法,Person类没有school成员变量

// 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。
```
开发中：
使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。
【开闭原则OCP】

- 对扩展开放，对修改关闭
- 通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能
### 虚方法调用
在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法。子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
举例：![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241940461.png&sign=b417ca53ef65c37501a35e54ba930afd1b92e31a8e18cd9c41d30798adf580c0#from=url&id=nJtQz&originHeight=182&originWidth=604&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
前提：Person类中定义了welcome()方法，各个子类重写了welcome()。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241940462.png#clientId=u5b5ef466-0026-4&from=url&id=ihspT&originHeight=253&originWidth=488&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubcc78d37-7802-420e-9a36-7e1cef5cdbc&title=)
执行：多态的情况下，调用对象的welcome()方法，实际执行的是子类重写的方法。
拓展：
静态链接（或早起绑定）：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。
动态链接（或晚期绑定）：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。
### 成员变量没有多态性

- 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。
- 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量
```java
package com.atguigu.polymorphism.grammar;

public class TestVariable {
    public static void main(String[] args) {
        Base b = new Sub();
        System.out.println(b.a);
        System.out.println(((Sub)b).a);

        Sub s = new Sub();
        System.out.println(s.a);
        System.out.println(((Base)s).a);
    }
}
class Base{
    int a = 1;
}
class Sub extends Base{
    int a = 2;
}
```
### 向上转型与向下转型
首先，一个对象在new的时候创建是哪个类型的对象，它从头至尾都不会变。即这个对象的运行时类型，本质的类型用于不会变。但是，把这个对象赋值给不同类型的变量时，这些变量的编译时类型却不同。
#### 为什么要类型转换
因为多态，就一定会把子类对象赋值父类变量的时候，这个时候，在编译期间，就会出现类型转换的现象。但是，使用父类变量接受子类对象之后，我们就不能调用子类拥有，而父类没有的方法了。这也是多态给我们的"小麻烦"。所以，想要调用子类特有的方法，必须类型转换，使得编译通过
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241940463.png&sign=33b6b20f43323eb8a3ca0e535aff33be9e3e1a603ac3d7dc9447a03c3710ca50#from=url&id=zYBQI&originHeight=526&originWidth=1018&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)

- **向上转型**：当左边的变量的类型（父类） > 右边对象/变量的类型（子类），我们就称为向上转型
   - 此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类特有的变量和方法了
   - 但是，**运行时，仍然是对象本身的类型**，所以执行的方法是子类重写的方法体。
   - 此时，一定是安全的，而且也是自动完成的
- **向下转型**：当左边的变量的类型（子类）<右边对象/变量的编译时类型（父类），我们就称为向下转型
   - 此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了
   - 但是，**运行时，仍然是对象本身的类型**
   - 不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException，为了安全，可以通过isInstanceof关键字进行判断
#### 如何向上或向下转型
向上转型：自动完成
向下转型：(子类类型)父类变量
```java
package com.atguigu.polymorphism.grammar;

public class ClassCastTest {
    public static void main(String[] args) {
        //没有类型转换
        Dog dog = new Dog();//dog的编译时类型和运行时类型都是Dog

        //向上转型
        Pet pet = new Dog();//pet的编译时类型是Pet，运行时类型是Dog
        pet.setNickname("小白");
        pet.eat();//可以调用父类Pet有声明的方法eat，但执行的是子类重写的eat方法体
//        pet.watchHouse();//不能调用父类没有的方法watchHouse

        Dog d = (Dog) pet;
        System.out.println("d.nickname = " + d.getNickname());
        d.eat();//可以调用eat方法
        d.watchHouse();//可以调用子类扩展的方法watchHouse

        Cat c = (Cat) pet;//编译通过，因为从语法检查来说，pet的编译时类型是Pet，Cat是Pet的子类，所以向下转型语法正确
        //这句代码运行报错ClassCastException，因为pet变量的运行时类型是Dog，Dog和Cat之间是没有继承关系的
    }
}
```
#### instanceof关键字
为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验。如下代码格式：
```java
//检验对象a是否是数据类型A的对象，返回值为boolean型
对象a instanceof 数据类型A
```
说明：

   - 只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。
   - 如果对象a属于类A的子类B，a instanceof A值也为true。
   - 要求对象a所属的类与类A必须是子类和父类的关系，否则编译错误。
```java
package com.atguigu.polymorphism.grammar;

public class TestInstanceof {
    public static void main(String[] args) {
        Pet[] pets = new Pet[2];
        pets[0] = new Dog();//多态引用
        pets[0].setNickname("小白");
        pets[1] = new Cat();//多态引用
        pets[1].setNickname("雪球");

        for (int i = 0; i < pets.length; i++) {
            pets[i].eat();

            if(pets[i] instanceof Dog){
                Dog dog = (Dog) pets[i];
                dog.watchHouse();
            }else if(pets[i] instanceof Cat){
                Cat cat = (Cat) pets[i];
                cat.catchMouse();
            }
        }
    }
}
```

## 方法的重写
父类的所有方法子类都会继承，但是当某个方法被继承到子类之后，子类觉得 
父类原来的实现不适合于自己当前的类，该怎么办呢？子类可以对从父类中继 
承来的方法进行改造，我们称为方法的_重写 (override、overwrite)_。也称为 
方法的_重置_、_覆盖_。 
在程序执行时，子类的方法将覆盖父类的方法。
### 方法重写举例
```
package com.atguigu.inherited.method;

public class Phone {
    public void sendMessage(){
        System.out.println("发短信");
    }
    public void call(){
        System.out.println("打电话");
    }
    public void showNum(){
        System.out.println("来电显示号码");
    }
}
package com.atguigu.inherited.method;

//SmartPhone：智能手机
public class SmartPhone extends Phone{
    //重写父类的来电显示功能的方法
	@Override
    public void showNum(){
        //来电显示姓名和图片功能
        System.out.println("显示来电姓名");
        System.out.println("显示头像");
    }
    //重写父类的通话功能的方法
    @Override
    public void call() {
        System.out.println("语音通话 或 视频通话");
    }
}
package com.atguigu.inherited.method;

public class TestOverride {
    public static void main(String[] args) {
        // 创建子类对象
        SmartPhone sp = new SmartPhone();

        // 调用父类继承而来的方法
        sp.call();

        // 调用子类重写的方法
        sp.showNum();
    }
}
```
### 方法重写的要求
1. 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表。
2. 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。（例如：Student < Person）。
注意：如果返回值类型是基本数据类型和void，那么必须是相同
1. 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。（public > protected > 缺省 > private）
注意：① 父类私有方法不能重写 ② 跨包的父类缺省的方法也不能重写
1. 子类方法抛出的异常不能大于父类被重写方法的异常
此外，子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。
## 再谈封装性中的4种权限修饰
权限修饰符：public,protected,缺省,private

| 修饰符 | 本类 | 本包 | 其他包子类 | 其他包非子类 |
| --- | --- | --- | --- | --- |
| private | √ | × | × | × |
| 缺省 | √ | √（本包子类非子类都可见） | × | × |
| protected | √ | √（本包子类非子类都可见） | √（其他包仅限于子类中可见） | × |
| public | √ | √ | √ | √ |

外部类：public和缺省
成员变量、成员方法等：public,protected,缺省,private
**1、外部类要跨包使用必须是public，否则仅限于本包使用**
（1）外部类的权限修饰符如果缺省，本包使用没问题
![](https://gitee.com/lvweixing/pictures/raw/master/202304241940446.png#clientId=u80adf2f2-205b-4&from=url&id=xAag7&originHeight=448&originWidth=1323&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7d051007-bc2b-47b6-bf8a-652092b2371&title=)
（2）外部类的权限修饰符如果缺省，跨包使用有问题
![](https://gitee.com/lvweixing/pictures/raw/master/202304241940447.png#clientId=u80adf2f2-205b-4&from=url&id=mWZS9&originHeight=562&originWidth=1329&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua4c1db83-38c6-492b-bc07-2d0a528489f&title=)
**2、成员的权限修饰符问题**
（1）本包下使用：成员的权限修饰符可以是public、protected、缺省
![](https://gitee.com/lvweixing/pictures/raw/master/202304241940448.png#clientId=u80adf2f2-205b-4&from=url&id=sMX4R&originHeight=580&originWidth=1326&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25a6ff6f-cbe6-44ad-9734-07ecb6ba3c5&title=)
（2）跨包下使用：要求严格
![](https://gitee.com/lvweixing/pictures/raw/master/202304241940449.png#clientId=u80adf2f2-205b-4&from=url&id=KxDAQ&originHeight=500&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u86974ce7-0076-47b0-b27b-48359c54d64&title=)
（3）跨包使用时，如果类的权限修饰符缺省，成员权限修饰符>类的权限修饰符也没有意义
![](https://gitee.com/lvweixing/pictures/raw/master/202304241940450.png#clientId=u80adf2f2-205b-4&from=url&id=m4Gah&originHeight=239&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc682422b-5863-4ce3-97df-a878d954dc3&title=)
## super 与 this 关键字？
super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。
this关键字：指向自己的引用。
### this
this是一个关键字 ，全部小写
this是什么，在内存方面咋样的？
一个对象一个this, this是一个变量，是一个引用。this保存当前对象的内存地址，指向自身。
this代表的就是”当前对象“
this存储在堆内存当中对象的内部。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29688613/1664531495175-27b16da7-34b4-4c11-92ef-b28a88cef8b2.png#averageHue=%23f9f8f7&clientId=u3d00b6b5-0ff9-4&from=paste&height=278&id=uc1cf7e61&originHeight=344&originWidth=700&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67784&status=done&style=none&taskId=u76aebedf-0da8-4f8e-b5ff-ed338490667&title=&width=564.7058642505722)
#### 什么时候使用this
##### 实例方法或构造器中使用当前对象的成员
在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，通常我们都习惯省略this。
但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分成员变量和局部变量。比如：
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241940423.png&sign=921751835943ae4dc790330ad8603813bbbe2ee537e52c8d8364ecba3bb9b64b#from=url&id=S0oND&originHeight=325&originWidth=1013&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
另外，使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。这个在继承中会讲到。
##### 同一个类中构造器互相调用
this 可以作为一个类中构造器相互调用的特殊格式。
this()：调用本类的无参构造器 
this(实参列表)：调用本类的有参构造器
```
public class Student {
   private String name;
   private int age;
   // 无参构造
   public Student() {
  // this("",18);//调用本类有参构造器
 }
 // 有参构造
 public Student(String name) {
   this();//调用本类无参构造器
   this.name = name;
 }
 // 有参构造
 public Student(String name,int age){
   this(name);//调用本类中有一个 String 参数的构造器
   this.age = age;
 }
 public String getName() {
   return name;
 }
 public void setName(String name) {
   this.name = name;
 }
 public int getAge() {
   return age;
 }
 public void setAge(int age) {
   this.age = age;
 }
 public String getInfo(){
   return "姓名：" + name +"，年龄：" + age;
 }
}
```
不能出现递归调用。比如，调用自身构造器。 
推论：如果一个类中声明了 n 个构造器，则最多有 n - 1 个构造器中使用 了"this(形参列表)" 
this()和 this(实参列表)只能声明在构造器首行。 
推论：在类的一个构造器中，最多只能声明一个"this(参数列表)"
### super
#### super理解
在 Java 类中使用 super 来调用父类中的指定操作： 
super 可用于访问父类中定义的属性 
super 可用于调用父类中定义的成员方法 
super 可用于在子类构造器中调用父类的构造器 
注意： 
尤其当子父类出现同名成员时，可以用 super 表明调用的是父类中的成员
super 的追溯不仅限于直接父类 
super 和 this 的用法相像，this 代表本类对象的引用，super 代表父类的内存空间的标 识
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29688613/1664616245978-76693d22-e34c-4110-a2e8-83a21b29cd34.png#averageHue=%23f6f6f6&clientId=ub09bc86d-353f-4&from=paste&height=290&id=u00266569&originHeight=360&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&size=110335&status=done&style=none&taskId=ub87ab024-a08f-4304-949f-8907fe5d3b0&title=&width=580.0335948516591)
#### **super 的使用场景**
##### 子类调用父类被重写的方法
如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法；
如果子类重写了父类的方法，在子类中需要通过super,才能调用父类被重写的方法，否则默认调用的子类重写的方法
```
package com.atguigu.inherited.method;
public class Phone {
 public void sendMessage(){
 System.out.println("发短信");
 }
 public void call(){
 System.out.println("打电话");
 }
 public void showNum(){
 System.out.println("来电显示号码");
 }
}
//smartphone：智能手机
public class SmartPhone extends Phone{
 //重写父类的来电显示功能的方法
 public void showNum(){
 //来电显示姓名和图片功能
 System.out.println("显示来电姓名");
 System.out.println("显示头像");
 //保留父类来电显示号码的功能
 super.showNum();//此处必须加 super.，否则就是无限递归，那么就会栈
内存溢出
 }
}
```
总结：
**方法前面没有 super.和 this. **
先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯 
**方法前面有 this. **
先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯 
**方法前面有 super. **
从当前子类的直接父类找，如果没有，继续往上追溯
##### 子类调用父类的同名的成员变量
如果实例变量与局部变量重名，可以在实例变量前面加 this.进行区别
如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在 
子类中要访问父类声明的实例变量需要在父类实例变量前加 super.，否则默认访问的 
是子类自己声明的实例变量
如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父 
类中声明的实例变量，也可以用 this.实例访问，也可以用 super.实例变量访问
```
class Father{
	int a = 10;
	int b = 11;
}
class Son extends Father{
	int a = 20;
    
    public void test(){
		//子类与父类的属性同名，子类对象中就有两个a
		System.out.println("子类的a：" + a);//20  先找局部变量找，没有再从本类成员变量找
        System.out.println("子类的a：" + this.a);//20   先从本类成员变量找
        System.out.println("父类的a：" + super.a);//10    直接从父类成员变量找
		
		//子类与父类的属性不同名，是同一个b
		System.out.println("b = " + b);//11  先找局部变量找，没有再从本类成员变量找，没有再从父类找
		System.out.println("b = " + this.b);//11   先从本类成员变量找，没有再从父类找
		System.out.println("b = " + super.b);//11  直接从父类局部变量找
	}
	
	public void method(int a, int b){
		//子类与父类的属性同名，子类对象中就有两个成员变量a，此时方法中还有一个局部变量a		
		System.out.println("局部变量的a：" + a);//30  先找局部变量
        System.out.println("子类的a：" + this.a);//20  先从本类成员变量找
        System.out.println("父类的a：" + super.a);//10  直接从父类成员变量找

        System.out.println("b = " + b);//13  先找局部变量
		System.out.println("b = " + this.b);//11  先从本类成员变量找
		System.out.println("b = " + super.b);//11  直接从父类局部变量找
    }
}
class Test{
    public static void main(String[] args){
        Son son = new Son();
		son.test();
		son.method(30,13);  
    }
}
```
总结:起点不同(就近原则)
变量前面没有super.和this.

- **变量前面没有super.和this.**
   - 在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的局部变量，
   - 如果不是局部变量，先从当前执行代码的本类去找成员变量
   - 如果从当前执行代码的本类中没有找到，会往上找父类声明的成员变量（权限修饰符允许在子类中访问的）
- **变量前面有this.**
   - 通过this找成员变量时，先从当前执行代码的本类去找成员变量
   - 如果从当前执行代码的本类中没有找到，会往上找==父类声明的成员变量（==权限修饰符允许在子类中访问的）
- **变量前面super.**
   - 通过super找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的）
   - 如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的）

**特此说明:应该避免子类声明和父类重名的成员变量**
##### 子类构造器调用父类构造器
1.子类继承父类时，不会继承父类的构造器，只能通过"super"的方式调用父类指定的构造器。
2.规定：super(形参列表)必须声明构造器的首行
3.我们前面讲过，在构造器的首行可以使用"this(形参列表)"，调用本类中重载的构造器，
结合②，结论：在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。
4.如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，
则子类此构造器默认调用"super()"，即调用父类中空参的构造器。
5.由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。
6.由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了"this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。
开发中常见错误：
如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则编译出错。
情景举例1：
```java
class A{

}
class B extends A{

}

class Test{
    public static void main(String[] args){
        B b = new B();
        //A类和B类都是默认有一个无参构造，B类的默认无参构造中还会默认调用A类的默认无参构造
        //但是因为都是默认的，没有打印语句，看不出来
    }
}
```
情景举例2：
```java
class A{
	A(){
		System.out.println("A类无参构造器");
	}
}
class B extends A{

}
class Test{
    public static void main(String[] args){
        B b = new B();
        //A类显示声明一个无参构造，
		//B类默认有一个无参构造，
		//B类的默认无参构造中会默认调用A类的无参构造
        //可以看到会输出“A类无参构造器"
    }
}
```
情景举例3：
```java
class A{
	A(){
		System.out.println("A类无参构造器");
	}
}
class B extends A{
	B(){
		System.out.println("B类无参构造器");
	}
}
class Test{
    public static void main(String[] args){
        B b = new B();
        //A类显示声明一个无参构造，
		//B类显示声明一个无参构造，        
		//B类的无参构造中虽然没有写super()，但是仍然会默认调用A类的无参构造
        //可以看到会输出“A类无参构造器"和"B类无参构造器")
    }
}
```
情景举例4：
```java
class A{
	A(){
		System.out.println("A类无参构造器");
	}
}
class B extends A{
	B(){
        super();
		System.out.println("B类无参构造器");
	}
}
class Test{
    public static void main(String[] args){
        B b = new B();
        //A类显示声明一个无参构造，
		//B类显示声明一个无参构造，        
		//B类的无参构造中明确写了super()，表示调用A类的无参构造
        //可以看到会输出“A类无参构造器"和"B类无参构造器")
    }
}
```
情景举例5：
```java
class A{
	A(int a){
		System.out.println("A类有参构造器");
	}
}
class B extends A{
	B(){
		System.out.println("B类无参构造器");
	}
}
class Test05{
    public static void main(String[] args){
        B b = new B();
        //A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了
		//B类显示声明一个无参构造，        
		//B类的无参构造没有写super(...)，表示默认调用A类的无参构造
        //编译报错，因为A类没有无参构造
    }
}
```
![](https://gitee.com/lvweixing/pictures/raw/master/202304241940453.png#clientId=u5b5ef466-0026-4&from=url&id=aN1dt&originHeight=457&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua7332b85-10f5-4f70-8959-85c572e4608&title=)
情景举例6：
```java
class A{
	A(int a){
		System.out.println("A类有参构造器");
	}
}
class B extends A{
	B(){
		super();
		System.out.println("B类无参构造器");
	}
}
class Test06{
    public static void main(String[] args){
        B b = new B();
        //A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了
		//B类显示声明一个无参构造，        
		//B类的无参构造明确写super()，表示调用A类的无参构造
        //编译报错，因为A类没有无参构造
    }
}
```
![](https://gitee.com/lvweixing/pictures/raw/master/202304241940454.png#clientId=u5b5ef466-0026-4&from=url&id=C7cxg&originHeight=437&originWidth=677&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub51f3ef0-c80b-40c9-82c5-4ed5468524c&title=)
情景举例7：
```java
class A{
	A(int a){
		System.out.println("A类有参构造器");
	}
}
class B extends A{
	B(int a){
		super(a);
		System.out.println("B类有参构造器");
	}
}
class Test07{
    public static void main(String[] args){
        B b = new B(10);
        //A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了
		//B类显示声明一个有参构造，        
		//B类的有参构造明确写super(a)，表示调用A类的有参构造
        //会打印“A类有参构造器"和"B类有参构造器"
    }
}
```
情景举例8：
```java
class A{
    A(){
        System.out.println("A类无参构造器");
    }
	A(int a){
		System.out.println("A类有参构造器");
	}
}
class B extends A{
    B(){
        super();//可以省略，调用父类的无参构造
        System.out.println("B类无参构造器");
    }
	B(int a){
		super(a);//调用父类有参构造
		System.out.println("B类有参构造器");
	}
}
class Test8{
    public static void main(String[] args){
        B b1 = new B();
        B b2 = new B(10);
    }
}
```
### 5.3 小结：this与super
**1、this和super的意义**
this：当前对象

- 在构造器和非静态代码块中，表示正在new的对象
- 在实例方法中，表示调用当前方法的对象

super：引用父类声明的成员
**2、this和super的使用格式**

- this 
   - this.成员变量：表示当前对象的某个成员变量，而不是局部变量
   - this.成员方法：表示当前对象的某个成员方法，完全可以省略this.
   - this()或this(实参列表)：调用另一个构造器协助当前对象的实例化，只能在构造器首行，只会找本类的构造器，找不到就报错
- super 
   - super.成员变量：表示当前对象的某个成员变量，该成员变量在父类中声明的
   - super.成员方法：表示当前对象的某个成员方法，该成员方法在父类中声明的
   - super()或super(实参列表)：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错
### 子类对象实例化全过程
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241940458.png&sign=e87332433bc446f0ef76836d15b3d6e3f17f6b3b86a6435f694f38ff85bf0679#from=url&id=wFzwt&originHeight=357&originWidth=684&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
## Object类的使用
![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710234126004-a62d5ee5-556b-4175-ae3a-409416ed2c49.png#averageHue=%23fdefe3&clientId=uf6f9230a-eb1d-4&from=paste&id=u02646e1d&originHeight=800&originWidth=1006&originalType=url&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&taskId=u6ca18116-be84-42a2-9d08-17595ad1b69&title=)
### 如何理解根父类
类java.lang.Object 是类层次结构的根类，即所有其它类的父类。每个类都使用Object作为超类
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241940465.png&sign=c08c14f3c1dd212563e511441058b479964e3c83afc045ee124fd9916a0b5d14#from=url&id=eKJgy&originHeight=394&originWidth=1088&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)

- Object类型的变量与除Object以外的任意引用数据类型的对象都存在多态引用
```java
method(Object obj){…} //可以接收任何类作为其参数

Person o = new Person();  
method(o);
```

- 所有对象（包括数组）都实现这个类的方法。
- 如果一个类没有特别指定父类，那么默认则继承自Object类。例如：
```java
public class Person {
	...
}
//等价于：
public class Person extends Object {
	...
}
```
### Object类的方法
根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。这里我们主要关注其中的6个：
#### equals()*
== 基本类型比较值：只要两个变量的值相等，即为true
```java
int a=5; 
if(a==6){…}
```
引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true
```java
Person p1=new Person();  	    
Person p2=new Person();
if (p1==p2){…}
```

   - 用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错

**equals()：**所有类都继承了Object，也就获得了equals()方法。还可以重写。
只能比较引用类型，Object类源码中equals()的作用与“==”相同：比较是否指向同一个对象。
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241940466.png&sign=ea2145b452bcc8e6a780e2633d78762767ac9df639b5004ed7bc1a779814149c#from=url&id=aIfKK&originHeight=530&originWidth=1478&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)

- 格式:obj1.equals(obj2)
- 当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；
- 原因：在这些类中重写了Object类的equals()方法。
- 当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等
- 重写equals()方法的原则
   - 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。
   - 自反性：x.equals(x)必须返回是“true”。
   - 传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。
   - 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。
   - 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。

重写举例
```java
class User{
	private String host;
	private String username;
	private String password;
	public User(String host, String username, String password) {
		super();
		this.host = host;
		this.username = username;
		this.password = password;
	}
	public User() {
		super();
	}
	public String getHost() {
		return host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	@Override
	public String toString() {
		return "User [host=" + host + ", username=" + username + ", password=" + password + "]";
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		User other = (User) obj;
		if (host == null) {
			if (other.host != null)
				return false;
		} else if (!host.equals(other.host))
			return false;
		if (password == null) {
			if (other.password != null)
				return false;
		} else if (!password.equals(other.password))
			return false;
		if (username == null) {
			if (other.username != null)
				return false;
		} else if (!username.equals(other.username))
			return false;
		return true;
	}
	
}
```
**面试题：**==和equals的区别
从我面试的反馈，85%的求职者“理直气壮”的回答错误…

- == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址
- equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。
- 具体要看自定义类里有没有重写Object的equals方法来判断。
- 通常情况下，重写equals方法，会比较类中的相应属性是否都相等。
#### toString()
方法签名：public String toString()
① 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式"
② 在进行String与其它类型数据的连接操作时，自动调用toString()方法
```java
Date now=new Date();
System.out.println(“now=”+now);  //相当于
System.out.println(“now=”+now.toString());
```
③ 如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()
因为Java的引用数据类型的变量中存储实际上是对象的内存地址，但是Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来，所以当你打印对象的时候，JVM帮你调用了对象的toString()
④ 可以根据需要在用户自定义类型中重写toString()方法
如String 类重写了toString()方法，返回字符串的值。
```java
s1="hello";
System.out.println(s1);//相当于System.out.println(s1.toString());
```
#### clone()
```java
//Object类的clone()的使用
public class CloneTest {
	public static void main(String[] args) {
		Animal a1 = new Animal("花花");
		try {
			Animal a2 = (Animal) a1.clone();
			System.out.println("原始对象：" + a1);
			a2.setName("毛毛");
			System.out.println("clone之后的对象：" + a2);
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
	}
}

class Animal implements Cloneable{
	private String name;

	public Animal() {
		super();
	}

	public Animal(String name) {
		super();
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "Animal [name=" + name + "]";
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}
	
}
```
#### finalize()

- 当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的） 
   - 永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。
- 什么时候被回收：当某个对象没有任何引用时，JVM就认为这个对象是垃圾对象，就会在之后不确定的时间使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize()方法。
- 子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。 
   - 如果重写该方法，让一个新的引用变量重新引用该对象，则会重新激活对象。
- 在JDK 9中此方法已经被标记为过时的。
```java
public class FinalizeTest {
	public static void main(String[] args) {
		Person p = new Person("Peter", 12);
		System.out.println(p);
		p = null;//此时对象实体就是垃圾对象，等待被回收。但时间不确定。
		System.gc();//强制性释放空间
	}
}

class Person{
	private String name;
	private int age;

	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	//子类重写此方法，可在释放对象前进行某些操作
	@Override
	protected void finalize() throws Throwable {
		System.out.println("对象被释放--->" + this);
	}
	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
	
}
```
#### getClass()
public final Class<?> getClass()：获取对象的运行时类型
因为Java有多态现象，所以一个引用数据类型的变量的编译时类型与运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象的类型，需要用getClass()方法
```java
public static void main(String[] args) {
	Object obj = new Person();
	System.out.println(obj.getClass());//运行时类型
}
```
结果
```java
class com.atguigu.java.Person
```
#### hashCode()
public int hashCode()：返回每个对象的hash值。(后续在集合框架章节重点讲解)
```java
public static void main(String[] args) {
	System.out.println("AA".hashCode());//2080
    System.out.println("BB".hashCode());//2112
}
```
### native关键字的理解
使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++等非Java语言实现的，并且被编译成了DLL，由Java去调用。
DLL是作为函数和资源共享库的一种可执行文件。动态链接是操作系统的功能。

- 本地方法是有方法体的，用c语言编写。由于本地方法的方法体源码没有对我们开源，所以我们看不到方法体
- 在Java中定义一个native方法时，并不提供实现体。

**1. 为什么要用native方法**
Java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，例如：Java需要与一些底层操作系统或某些硬件交换信息时的情况。native方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。
**2. native声明的方法，对于调用者，可以当做和其他Java方法一样使用**
native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。
## static关键字
**回顾类中的实例变量（即非static的成员变量）**
```java
class Circle{
	private double radius;
	public Circle(double radius){
        this.radius=radius;
	}
	public double findArea(){
        return Math.PI*radius*radius;
    }
}
```
创建两个Circle对象：
```java
Circle c1=new Circle(2.0);	//c1.radius=2.0
Circle c2=new Circle(3.0);	//c2.radius=3.0
```
Circle类中的变量radius是一个实例变量(instance variable)，它属于类的每一个对象，c1中的radius变化不会影响c2的radius，反之亦然。
**如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）！**
### 类属性，类方法的设计思想
当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份。例如，所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946074.png&sign=a7aebfa39f0e4f4f8be5e1929d73077ccec069852d3f06fc63b75fa64e9e9dfb#from=url&id=gIWla&originHeight=157&originWidth=495&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
此外，在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是有些方法的调用者和当前类的对象无关，这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。
这里的类变量、类方法，只需要使用static修饰即可。所以也称为静态变量、静态方法。

- 使用范围：
   - 在Java类中，可用static修饰属性、方法、代码块、内部类
- 被修饰后的成员具备以下特点：
   - 随着类的加载而加载
   - 优先于对象存在
   - 修饰的成员，被所有对象所共享
   - 访问权限允许时，可不创建对象，直接被类调用
### 静态变量
#### 特点

- 静态变量的默认值规则和实例变量一样。
- 静态变量值是所有对象共享。
- 静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。
- 如果权限修饰符允许，在其他类中可以通过“类名.静态变量”直接访问，也可以通过“对象.静态变量”的方式访问（但是更推荐使用类名.静态变量的方式）。
- 静态变量的get/set方法也静态的，当局部变量与静态变量重名时，使用“类名.静态变量”进行区分。

eg:
```java
class Chinese{
    //实例变量
    String name;
    int age;
    //类变量
    static String nation;//国籍

    public Chinese() {
    }

    public Chinese(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Chinese{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", nation='" + nation + '\'' +
                '}';
    }
}
public class StaticTest {
    public static void main(String[] args) {
        Chinese c1 = new Chinese("康师傅",36);
        c1.nation = "中华人民共和国";

        Chinese c2 = new Chinese("老干妈",66);

        System.out.println(c1);
        System.out.println(c2);

        System.out.println(Chinese.nation);
    }
}
```
对应的内存结构：（以经典的JDK6内存解析为例，此时静态变量存储在方法区）
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946075.png&sign=b4790131eadd8fe312b9622dfc37dbc9d247c30ea168838df087e62cdd7b5612#from=url&id=VCCS7&originHeight=602&originWidth=721&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
举例：
```java
package com.atguigu.keyword;

public class Employee {
    private static int total;//这里私有化，在类的外面必须使用get/set方法的方式来访问静态变量
    static String company; //这里缺省权限修饰符，是为了方便类外以“类名.静态变量”的方式访问
    private int id;
    private String name;

    public Employee() {
        total++;
        id = total;//这里使用total静态变量的值为id属性赋值
    }

    public Employee(String name) {
        this();
        this.name = name;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public static int getTotal() {
        return total;
    }

    public static void setTotal(int total) {
        Employee.total = total;
    }

    @Override
    public String toString() {
        return "Employee{company = " + company + ",id = " + id + " ,name=" + name +"}";
    }
}
```
```java
package com.atguigu.keyword;

public class TestStaticVariable {
    public static void main(String[] args) {
        //静态变量total的默认值是0
        System.out.println("Employee.total = " + Employee.getTotal());

        Employee e1 = new Employee("张三");
        Employee e2 = new Employee("李四");
        System.out.println(e1);//静态变量company的默认值是null
        System.out.println(e2);//静态变量company的默认值是null
        System.out.println("Employee.total = " + Employee.getTotal());//静态变量total值是2

        Employee.company = "尚硅谷";
        System.out.println(e1);//静态变量company的值是尚硅谷
        System.out.println(e2);//静态变量company的值是尚硅谷

        //只要权限修饰符允许,虽然不推荐，但是也可以通过“对象.静态变量”的形式来访问
        e1.company = "超级尚硅谷";

        System.out.println(e1);//静态变量company的值是超级尚硅谷
        System.out.println(e2);//静态变量company的值是超级尚硅谷
    }
}
```
内存解析
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946076.png&sign=40ee5b21b779b768cab139bdbdc1e49adeb7f327914ba9bbadabf98923cd1ea0#from=url&id=Jcdj6&originHeight=531&originWidth=884&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
### 静态方法
#### 语法格式
```java
[修饰符] class 类{
	[其他修饰符] static 返回值类型 方法名(形参列表){
        方法体
    }
}
```
#### 静态方法的特点

- 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。
- 只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。
- 在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。
- 静态方法可以被子类继承，但不能被子类重写。
- 静态方法的调用都只看编译时类型。
- 因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。

eg:
```java
package com.atguigu.keyword;

public class Father {
    public static void method(){
        System.out.println("Father.method");
    }

    public static void fun(){
        System.out.println("Father.fun");
    }
}
```
```java
package com.atguigu.keyword;

public class Son extends Father{
//    @Override //尝试重写静态方法，加上@Override编译报错，去掉Override不报错，但是也不是重写
    public static void fun(){
        System.out.println("Son.fun");
    }
}
```
```java
package com.atguigu.keyword;

public class TestStaticMethod {
    public static void main(String[] args) {
        Father.method();
        Son.method();//继承静态方法

        Father f = new Son();
        f.method();//执行Father类中的method
    }
}
```
## final关键字
### final的意义
final：最终的，不可更改的
### final的使用
#### final修饰类
表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。
例如：String类、System类、StringBuffer类
```java
final class Eunuch{//太监类
	
}
class Son extends Eunuch{//错误
	
}
```
####  final修饰方法
表示这个方法不能被子类重写。
例如：Object类中的getClass()
```java
class Father{
	public final void method(){
		System.out.println("father");
	}
}
class Son extends Father{
	public void method(){//错误
		System.out.println("son");
	}
}
```
#### final修饰变量
final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。
例如：final double MY_PI = 3.14;
如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）

- 修饰成员变量
```java
public final class Test {
    public static int totalNumber = 5;
    public final int ID;

    public Test() {
        ID = ++totalNumber; // 可在构造器中给final修饰的“变量”赋值
    }
    public static void main(String[] args) {
        Test t = new Test();
        System.out.println(t.ID);
    }
}
```
修饰局部变量
```java
public class TestFinal {
    public static void main(String[] args){
        final int MIN_SCORE ;
        MIN_SCORE = 0;
        final int MAX_SCORE = 100;
        MAX_SCORE = 200; //非法
    }
}
```
错误演示
```java
class A {
    private final String INFO = "atguigu";  //声明常量

    public void print() {
        //The final field A.INFO cannot be  assigned
        //INFO = "尚硅谷"; 
    }
}
```


## 单例(Singleton)设计模式
**设计模式**是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。"套路"
经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法。
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946077.png&sign=e4bdddc9f39be8d0d46909a070c3d8a5768023064c143c29376680f0b782d2a0#from=url&id=LNsx8&originHeight=447&originWidth=707&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
### 何为单例模式
所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法。
### 实现思路
如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。
### 单例模式的两种实现方式
#### 饿汉式
```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }

    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single = new Singleton();

    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        return single;
    }
}
```
#### 懒汉式
```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }
    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single;
    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        if(single == null) {
            single = new Singleton();
        }
        return single;
    }
}
```
#### 饿汉式与懒汉式
饿汉式：

- 特点：立即加载，即在使用类的时候已经将对象创建完毕。
- 优点：实现起来简单；没有多线程安全问题。
- 缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会耗费内存。

懒汉式：

- 特点：延迟加载，即在调用静态方法时实例才被创建。
- 优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会节约内存。
- 缺点：在多线程环境中，这种实现方法是完全错误的，线程不安全，根本不能保证单例的唯一性。 
   - 说明：在多线程章节，会将懒汉式改造成线程安全的模式。
### 单例模式的优点及其使用场景
由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946078.png&sign=111952683c59ce43f08c4deb3b07302ac690f1e81637be7b43134f46ed250ded#from=url&id=EV8Ft&originHeight=474&originWidth=913&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
应用场景：

- Windows的Task Manager (任务管理器)就是很典型的单例模式
- Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
- Application 也是单例的典型应用
- 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
## 理解main方法的语法
由于JVM需要调用类main()方法，所以该方法的访问权限必须是public,有因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接受一个String类型的数组参数，该数组中保存执行JAVA命令是传递所运行的类的参数。
又因为main()方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。
```java
public class CommandPara {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println("args[" + i + "] = " + args[i]);
        }
    }
}
```
```java
//运行程序CommandPara.java
java CommandPara "Tom" "Jerry" "Shkstart"
```
```java
//输出结果
args[0] = Tom
args[1] = Jerry
args[2] = Shkstart
```
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946079.png&sign=2c2ecc7116835bf180b8f788a0a97f99580776df5fe68b1b6dd076d1ce9ad45a#from=url&id=kkbHu&originHeight=160&originWidth=522&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
IDEA工具
1.配置运行参数
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946080.png&sign=e83a03c055abbb508f5093a66db8062ffb5cf5b72b083f07112500c1cf7cb21b#from=url&id=Ezcj1&originHeight=303&originWidth=371&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946081.png&sign=3161544caf842e31c2a393ac0593aea604e5138f4638252929bc3149081d8e9b#from=url&id=Npc1o&originHeight=525&originWidth=1076&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
运行程序
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946082.png&sign=f2fb7a9c06d4aa7c3f6297b1546da0ec226675d4320dfb509585f4e7476e9e70#from=url&id=Cs19I&originHeight=335&originWidth=746&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
```java
//此处，Something类的文件名叫OtherThing.java
class Something {
    public static void main(String[] something_to_do) {        
        System.out.println("Do something ...");
    }
}
//上述程序是否可以正常编译、运行？
```
## 抽象类与抽象方法(Abstarct关键字)
### 由来
举例1：
随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。
![](https://gitee.com/lvweixing/pictures/raw/master/202304241946084.png#clientId=uf6f9230a-eb1d-4&from=url&id=K3RWZ&originHeight=198&originWidth=341&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc90b0034-8b36-4892-9730-5aaa75c291a&title=)
举例2：
我们声明一些几何图形类：圆、矩形、三角形类等，发现这些类都有共同特征：求面积、求周长。那么这些共同特征应该抽取到一个共同父类：几何图形类中。但是这些方法在父类中又无法给出具体的实现，而是应该交给子类各自具体实现。那么父类在声明这些方法时，就只有方法签名，没有方法体，我们把没有方法体的方法称为**抽象方法**。Java语法规定，包含抽象方法的类必须是**抽象类**。
### 语法格式

- **抽象类**：被abstract修饰的类。
- **抽象方法**：被abstract修饰没有方法体的方法。

抽象类的语法格式
```java
[权限修饰符] abstract class 类名{
    
}
[权限修饰符] abstract class 类名 extends 父类{
    
}
```
抽象方法的语法格式
```java
[其他修饰符] abstract 返回值类型 方法名([形参列表]);
```
注意：抽象方法没有方法体
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946085.png&sign=5e145f4c512f807eaff2b40bae3efbdccb277d0e1c3efd0ff4a702c65be926be#from=url&id=zk4Wl&originHeight=69&originWidth=575&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
代码举例
```java
public abstract class Animal {
    public abstract void eat();
}
```
```java
public class Cat extends Animal {
    public void eat (){
      	System.out.println("小猫吃鱼和猫粮"); 
    }
}
```
```java
public class CatTest {
 	 public static void main(String[] args) {
        // 创建子类对象
        Cat c = new Cat(); 
       
        // 调用eat方法
        c.eat();
  	}
}
```
此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种重写的操作，也叫做实现方法
### 使用说明
1.抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。
2.抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。
3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。
4.抽象类的子类，必须重写抽象父类中的所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。
### 注意事项

- 不能用abstract修饰变量、代码块、构造器；
- 不能用abstract修饰私有方法、静态方法、final的方法、final的类
### 模板方法设计模式
抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。
**解决的问题**：

- 当功能内部一部分实现是确定的，另一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
- 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。

举例：
```java
package com.atguigu.java;
//抽象类的应用：模板方法的设计模式
public class TemplateMethodTest {

	public static void main(String[] args) {
		BankTemplateMethod btm = new DrawMoney();
		btm.process();

		BankTemplateMethod btm2 = new ManageMoney();
		btm2.process();
	}
}
abstract class BankTemplateMethod {
	// 具体方法
	public void takeNumber() {
		System.out.println("取号排队");
	}

	public abstract void transact(); // 办理具体的业务 //钩子方法

	public void evaluate() {
		System.out.println("反馈评分");
	}

	// 模板方法，把基本操作组合到一起，子类一般不能重写
	public final void process() {
		this.takeNumber();

		this.transact();// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码

		this.evaluate();
	}
}

class DrawMoney extends BankTemplateMethod {
	public void transact() {
		System.out.println("我要取款！！！");
	}
}

class ManageMoney extends BankTemplateMethod {
	public void transact() {
		System.out.println("我要理财！我这里有2000万美元!!");
	}
}
```
模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：

- 数据库访问的封装
- Junit单元测试
- JavaWeb的Servlet中关于doGet/doPost方法调用
- Hibernate中模板程序
- Spring中JDBCTemlate、HibernateTemplate等
## 接口
生活中大家每天都在用USB接口，那么USB接口与我们今天要学习的接口有什么相同点呢？
```java
USB，（Universal Serial Bus，通用串行总线）是Intel公司开发的总线架构，使得在计算机上添加串行设备（鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等）非常容易。
```
其实，不管不管是电脑上的USB插口，还是其他设备上的USB插口都只是遵循了USB规范的一种具体设备而已。
Java的软件系统会有很多模块组成，那么各个模块之间也应该采用这种面向接口的低耦合，为系统提供更好的可扩展性和可维护性。
### 概述
接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须 
能...”的思想。继承是一个"是不是"的 is-a 关系，而接口实现则是 "能不能"的 
_has-a _关系。
注意：
接口没有办法new对象
创建线程对象，采用匿名内部类方式
通过一个没有名字的类，new出来的对象。
如果接口的实现类是非抽象类，那么必须_重写接口中所有抽象方法_
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1704417791856-a269a36e-8e9e-4cfb-b88b-805c60043bc5.png#averageHue=%23b1c9af&clientId=ud1abc1bd-7020-4&from=paste&height=477&id=lBbXc&originHeight=591&originWidth=896&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=281405&status=done&style=none&taskId=u8d8e201d-f808-4599-b72b-92d0a9dc4fb&title=&width=722.8235062407323)

### 定义格式
接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。引用数据类型：数组，类，枚举，接口，注解。
```java
[修饰符] interface 接口名{
    //接口的成员列表：
    // 公共的静态常量
    // 公共的抽象方法
    
    // 公共的默认方法（JDK1.8以上）
    // 公共的静态方法（JDK1.8以上）
    // 私有方法（JDK1.9以上）
}
```
### 接口成员说明
**在JDK8.0 之前**，接口中只允许出现：
（1）公共的静态的常量：其中public static final可以省略
（2）公共的抽象的方法：其中public abstract可以省略
理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现
**在JDK8.0 时**，接口中允许声明默认方法和静态方法：
（3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略
（4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略
**在JDK9.0 时**，接口又增加了：
（5）私有方法
除此之外，接口中没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化。
### 接口使用规则
类实现接口
接口不能创建对象，但是可以被类实现（implements ，类似于被继承）。
类与接口的关系为实现关系，即**类实现接口**，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements关键字。
```java
【修饰符】 class 实现类  implements 接口{
	// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}

【修饰符】 class 实现类 extends 父类 implements 接口{
    // 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}
```
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946093.png&sign=6656459502f24cab2347e57dcc4a1b867710d3990d296b79560da32b5eb8e9f1#from=url&id=LBhrQ&originHeight=428&originWidth=755&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
注意：

1. 如果接口的实现类是非抽象类，那么必须重写接口中所有抽象方法。
2. 默认方法可以选择保留，也可以重写。重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了
3. 接口中的静态方法不能被继承也不能被重写
```java
interface USB{		// 
	public void start() ;
	public void stop() ;	
}
class Computer{
	public static void show(USB usb){	
		usb.start() ;
		System.out.println("=========== USB 设备工作 ========") ;
		usb.stop() ;
	}
};
class Flash implements USB{
	public void start(){	// 重写方法
		System.out.println("U盘开始工作。") ;
	}
	public void stop(){		// 重写方法
		System.out.println("U盘停止工作。") ;
	}
};
class Print implements USB{
	public void start(){	// 重写方法
		System.out.println("打印机开始工作。") ;
	}
	public void stop(){		// 重写方法
		System.out.println("打印机停止工作。") ;
	}
};
public class InterfaceDemo{
	public static void main(String args[]){
		Computer.show(new Flash()) ;
		Computer.show(new Print()) ;

		c.show(new USB(){
			public void start(){
				System.out.println("移动硬盘开始运行");
			}
			public void stop(){
				System.out.println("移动硬盘停止运行");
			}
		});
	}
};
```
**接口的多实现（implements）**
之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。
```java
【修饰符】 class 实现类  implements 接口1，接口2，接口3。。。{
	// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}

【修饰符】 class 实现类 extends 父类 implements 接口1，接口2，接口3。。。{
    // 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}
```
接口中，有多个抽象方法时，实现类必须重写所有抽象方法。**如果抽象方法有重名的，只需要重写一次**。
eg:
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946094.png&sign=2504ca637afe08ec872f9e65c453d5bd96ab42ccf53b0fef3f96866212cd6253#from=url&id=JQvCY&originHeight=373&originWidth=846&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946095.png&sign=c992ed40fbe5ac0e2896edd27ff0663625773e136c50edd8e8720a5805edb82d#from=url&id=EtWV6&originHeight=531&originWidth=998&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Flvweixing%2Fpictures%2Fraw%2Fmaster%2F202304241946096.png&sign=7f92a45d045848a04a9e625b9eb05caed25410e20cc97a44dbcd7f4e597b28db#from=url&id=jfcUB&originHeight=234&originWidth=698&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&status=done&style=none&title=)
```java
package com.atguigu.interfacetype;

public interface A {
    void showA();
}
```
```java
package com.atguigu.interfacetype;

public interface B {
    void showB();
}
```
定义实现类：

```java
package com.atguigu.interfacetype;

public class C implements A,B {
    @Override
    public void showA() {
        System.out.println("showA");
    }

    @Override
    public void showB() {
        System.out.println("showB");
    }
}
```

测试类

```java
package com.atguigu.interfacetype;

public class TestC {
    public static void main(String[] args) {
        C c = new C();
        c.showA();
        c.showB();
    }
}
```

**3、接口的多继承(extends)**
一个接口能继承另一个或者多个接口，接口的继承也使用 `extends` 关键字，子接口继承父接口的方法。
定义父接口：
```java
package com.atguigu.interfacetype;

public interface Chargeable {
    void charge();
    void in();
    void out();
}
```
定义子接口：
```java
package com.atguigu.interfacetype;

public interface UsbC extends Chargeable,USB3 {
    void reverse();
}
```
定义子接口的实现类：
```java
package com.atguigu.interfacetype;

public class TypeCConverter implements UsbC {
    @Override
    public void reverse() {
        System.out.println("正反面都支持");
    }

    @Override
    public void charge() {
        System.out.println("可充电");
    }

    @Override
    public void in() {
        System.out.println("接收数据");
    }

    @Override
    public void out() {
        System.out.println("输出数据");
    }
}
```

> 所有父接口的抽象方法都有重写。
> 方法签名相同的抽象方法只需要实现一次。

4.接口与实现类对象构成多态引用
实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。
接口的不同实现类：

```java
package com.atguigu.interfacetype;

public class Mouse implements USB3 {
    @Override
    public void out() {
        System.out.println("发送脉冲信号");
    }

    @Override
    public void in() {
        System.out.println("不接收信号");
    }
}
```

```java
package com.atguigu.interfacetype;

public class KeyBoard implements USB3{
    @Override
    public void in() {
        System.out.println("不接收信号");
    }

    @Override
    public void out() {
        System.out.println("发送按键信号");
    }
}
```

测试类

```java
package com.atguigu.interfacetype;

public class TestComputer {
    public static void main(String[] args) {
        Computer computer = new Computer();
        USB3 usb = new Mouse();
        computer.setUsb(usb);
        usb.start();
        usb.out();
        usb.in();
        usb.stop();
        System.out.println("--------------------------");

        usb = new KeyBoard();
        computer.setUsb(usb);
        usb.start();
        usb.out();
        usb.in();
        usb.stop();
        System.out.println("--------------------------");

        usb = new MobileHDD();
        computer.setUsb(usb);
        usb.start();
        usb.out();
        usb.in();
        usb.stop();
    }
}
```

**5、使用接口的静态成员**

接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。

```java
package com.atguigu.interfacetype;

public class TestUSB3 {
    public static void main(String[] args) {
        //通过“接口名.”调用接口的静态方法 (JDK8.0才能开始使用)
        USB3.show();
        //通过“接口名.”直接使用接口的静态常量
        System.out.println(USB3.MAX_SPEED);
    }
}
```

**6、使用接口的非静态方法**

- 对于接口的静态方法，直接使用“`接口名.`”进行调用即可 
   - 也只能使用“接口名."进行调用，不能通过实现类的对象进行调用
- 对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用 
   - 接口不能直接创建对象，只能创建实现类的对象

```java
package com.atguigu.interfacetype;

public class TestMobileHDD {
    public static void main(String[] args) {
        //创建实现类对象
        MobileHDD b = new MobileHDD();

        //通过实现类对象调用重写的抽象方法，以及接口的默认方法，如果实现类重写了就执行重写的默认方法，如果没有重写，就执行接口中的默认方法
        b.start();
        b.in();
        b.stop();

        //通过接口名调用接口的静态方法
//        MobileHDD.show();
//        b.show();
        Usb3.show();
    }
}
```

### JDK8中相关冲突问题
#### 默认方法冲突问题
**（1）类优先原则**
当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。代码如下：
定义接口：
```java
package com.atguigu.interfacetype;

public interface Friend {
    default void date(){//约会
        System.out.println("吃喝玩乐");
    }
}
```
定义父类：
```java
package com.atguigu.interfacetype;

public class Father {
    public void date(){//约会
        System.out.println("爸爸约吃饭");
    }
}
```
定义子类：
```java
package com.atguigu.interfacetype;

public class Son extends Father implements Friend {
    @Override
    public void date() {
        //(1)不重写默认保留父类的
        //(2)调用父类被重写的
//        super.date();
        //(3)保留父接口的
//        Friend.super.date();
        //(4)完全重写
        System.out.println("跟康师傅学Java");
    }
}
```
定义测试类：
```java
package com.atguigu.interfacetype;

public class TestSon {
    public static void main(String[] args) {
        Son s = new Son();
        s.date();
    }
}
```
**（2）接口冲突（左右为难）**

- 当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？

无论你多难抉择，最终都是要做出选择的。
声明接口：
```java
package com.atguigu.interfacetype;

public interface BoyFriend {
    default void date(){//约会
        System.out.println("神秘约会");
    }
}
```
选择保留其中一个，通过“`接口名.super.方法名`"的方法选择保留哪个接口的默认方法。
```java
package com.atguigu.interfacetype;

public class Girl implements Friend,BoyFriend{

    @Override
    public void date() {
        //(1)保留其中一个父接口的
//        Friend.super.date();
//        BoyFriend.super.date();
        //(2)完全重写
        System.out.println("跟康师傅学Java");
    }

}
```
测试类
```java
package com.atguigu.interfacetype;

public class TestGirl {
    public static void main(String[] args) {
        Girl girl = new Girl();
        girl.date();
    }
}
```

- 当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？

另一个父接口：
```java
package com.atguigu.interfacetype;

public interface USB2 {
    //静态常量
    long MAX_SPEED = 60*1024*1024;//60MB/s

    //抽象方法
    void in();
    void out();

    //默认方法
    public default void start(){
        System.out.println("开始");
    }
    public default void stop(){
        System.out.println("结束");
    }

    //静态方法
    public static void show(){
        System.out.println("USB 2.0可以高速地进行读写操作");
    }
}
```
子接口：
```java
package com.atguigu.interfacetype;

public interface USB extends USB2,USB3 {
    @Override
    default void start() {
        System.out.println("Usb.start");
    }

    @Override
    default void stop() {
        System.out.println("Usb.stop");
    }
}
```

> 小贴士：
> 子接口重写默认方法时，default关键字可以保留。
> 子类重写默认方法时，default关键字不可以保留。

####  常量冲突问题

- 当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。
- 当子类同时实现多个接口，而多个接口存在相同同名常量。

此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。
父类和父接口：
```java
package com.atguigu.interfacetype;

public class SuperClass {
    int x = 1;
}
```
```java
package com.atguigu.interfacetype;

public interface SuperInterface {
    int x = 2;
    int y = 2;
}
```
```java
package com.atguigu.interfacetype;

public interface MotherInterface {
    int x = 3;
}
```
子类：
```java
package com.atguigu.interfacetype;

public class SubClass extends SuperClass implements SuperInterface,MotherInterface {
    public void method(){
//        System.out.println("x = " + x);//模糊不清
        System.out.println("super.x = " + super.x);
        System.out.println("SuperInterface.x = " + SuperInterface.x);
        System.out.println("MotherInterface.x = " + MotherInterface.x);
        System.out.println("y = " + y);//没有重名问题，可以直接访问
    }
}
```
###  接口的总结与面试题

- 接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。
- 声明接口用interface，接口的成员声明有限制： 
   - （1）公共的静态常量
   - （2）公共的抽象方法
   - （3）公共的默认方法（JDK8.0 及以上）
   - （4）公共的静态方法（JDK8.0 及以上）
   - （5）私有方法（JDK9.0 及以上）
- 类可以实现接口，关键字是implements，而且支持多实现。如果实现类不是抽象类，就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（extends）在前，实现（implements）在后。
- 接口可以继承接口，关键字是extends，而且支持多继承。
- 接口的默认方法可以选择重写或不重写。如果有冲突问题，另行处理。子类重写父接口的默认方法，要去掉default，子接口重写父接口的默认方法，不要去掉default。
- 接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过“接口名.静态方法名”进行调用。

**面试题**

**1、为什么接口中只能声明公共的静态的常量？**

因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。

例如：USB1.0规范中规定最大传输速率是1.5Mbps，最大输出电流是5V/500mA

           USB3.0规范中规定最大传输速率是5Gbps(500MB/s)，最大输出电流是5V/900mA

例如：尚硅谷学生行为规范中规定学员，早上8:25之前进班，晚上21:30之后离开等等。

**2、为什么JDK8.0 之后允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。**

`静态方法`：因为之前的标准类库设计中，有很多Collection/Colletions或者Path/Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。

`默认方法`：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。

**3、为什么JDK1.9要允许接口定义私有方法呢？因为我们说接口是规范，规范是需要公开让大家遵守的。**

**私有方法**：因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。
### 接口与抽象类之间的对比
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710249306459-58745ab9-0e64-4bf9-9594-85dc605fd80c.png#averageHue=%239dbb89&clientId=uf6f9230a-eb1d-4&from=paste&height=445&id=ucb86ae16&originHeight=551&originWidth=1188&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=234123&status=done&style=none&taskId=u9d205bfe-f7d9-4671-a9db-ddb0a351202&title=&width=958.3865238995425)
> 在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。


### 标志接口
起到标识作用，Java虚拟机看到这个类实现这个接口，可以对这个类进行特殊待遇。
Serializable这个标识接口是给Java虚拟机参考，
Java虚拟机看到Serializable接口之后，会自动生成一个序列化版本号
这里没有手写出来，Java虚拟机默认提供这个序列化版本号
    序列化版本号有什么用？
Java语言采用什么机制区分类？
1.首先通过类名进行比对，如果类名不一样，肯定不是同一个类
2.如果类名一样，考序列化版本号进行区分。
缺点：
一旦代码确定之后，不能进行修改，因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候Java虚拟机会认为这是一个全新的类。凡是一个类实现了serializabale接口，建议给该类提供一个固定不变的序列化版本号。这样，以后这个类即使
代码修改了，但是版本号不变，Java虚拟机会认为是同一个类。
一次序列化多个对象呢？
序列化多个对象得用集合，不用集合的话就会报错
可以将对象放到集合当中，序列化集合
序列化一个集合，这个集合对象中放了很多其它对象。
transient关键字标识游离的，不参与序列化。
```
private transient String name ; // name不参与序列化操作
```

## 内部类
### 概述
#### 什么是内部类
将一个类A定义在另一个类B里面，里面的那个类A就称为`内部类（InnerClass）`，类B则称为`外部类（OuterClass）`。
#### 为什么要声明内部类呢
具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。
总的来说，遵循`高内聚、低耦合`的面向对象开发原则。
#### 内部类的分类
根据内部类声明的位置（如同变量的分类），我们可以分为：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710249531723-9de45d86-b5e9-4deb-a91f-5ea01d186478.png#averageHue=%23f6f5f4&clientId=uf6f9230a-eb1d-4&from=paste&height=213&id=NrBoe&originHeight=264&originWidth=613&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=40123&status=done&style=none&taskId=u1396958e-3f04-429a-97c3-8b18ab1ab1c&title=&width=494.5209925508582)
### 成员内部类
#### 概述
如果成员内部类中不使用外部类的非静态成员，那么通常将内部类声明为静态内部类，否则声明为非静态内部类。
**语法格式：**

```java
[修饰符] class 外部类{
    [其他修饰符] [static] class 内部类{
    }
}
```

**成员内部类的使用特征，概括来讲有如下两种角色：**

- 成员内部类作为`类的成员的角色`： 
   - 和外部类不同，Inner class还可以声明为private或protected；
   - 可以调用外部类的结构。（注意：在静态内部类中不能使用外部类的非静态成员）
   - Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；
- 成员内部类作为`类的角色`： 
   - 可以在内部定义属性、方法、构造器等结构
   - 可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关
   - 可以声明为abstract类 ，因此可以被其它的内部类继承
   - 可以声明为final的，表示不能被继承
   - 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）

注意点：

2.  外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 
3.  成员内部类可以直接使用外部类的所有成员，包括私有的数据 
4.  当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的 
#### 创建成员内部类对象

- 实例化静态内部类
```
外部类名.静态内部类名 变量 = 外部类名.静态内部类名();
变量.非静态方法();
```

- 实例化非静态内部类
```
外部类名 变量1 = new 外部类();
外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();
变量2.非静态方法();
```
#### 举例
```java
public class TestMemberInnerClass {
    public static void main(String[] args) {
        //创建静态内部类实例，并调用方法
        Outer.StaticInner inner = new Outer.StaticInner();
        inner.inFun();
        //调用静态内部类静态方法
        Outer.StaticInner.inMethod();

        System.out.println("*****************************");
        
        //创建非静态内部类实例（方式1），并调用方法
        Outer outer = new Outer();
        Outer.NoStaticInner inner1 = outer.new NoStaticInner();
        inner1.inFun();

        //创建非静态内部类实例（方式2）
        Outer.NoStaticInner inner2 = outer.getNoStaticInner();
        inner1.inFun();
    }
}
class Outer{
    private static String a = "外部类的静态a";
    private static String b  = "外部类的静态b";
    private String c = "外部类对象的非静态c";
    private String d = "外部类对象的非静态d";

    static class StaticInner{
        private static String a ="静态内部类的静态a";
        private String c = "静态内部类对象的非静态c";
        public static void inMethod(){
            System.out.println("Inner.a = " + a);
            System.out.println("Outer.a = " + Outer.a);
            System.out.println("b = " + b);
        }
        public void inFun(){
            System.out.println("Inner.inFun");
            System.out.println("Outer.a = " + Outer.a);
            System.out.println("Inner.a = " + a);
            System.out.println("b = " + b);
            System.out.println("c = " + c);
//            System.out.println("d = " + d);//不能访问外部类的非静态成员
        }
    }

    class NoStaticInner{
        private String a = "非静态内部类对象的非静态a";
        private String c = "非静态内部类对象的非静态c";

        public void inFun(){
            System.out.println("NoStaticInner.inFun");
            System.out.println("Outer.a = " + Outer.a);
            System.out.println("a = " + a);
            System.out.println("b = " + b);
            System.out.println("Outer.c = " + Outer.this.c);
            System.out.println("c = " + c);
            System.out.println("d = " + d);
        }
    }


    public NoStaticInner getNoStaticInner(){
        return new NoStaticInner();
    }
}
```

### 局部内部类
#### 非匿名局部内部类

语法格式：

```java
[修饰符] class 外部类{
    [修饰符] 返回值类型  方法名(形参列表){
            [final/abstract] class 内部类{
    	}
    }    
}
```

- 编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。 
   - 这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类

- 和成员内部类不同的是，它前面不能有权限修饰符等
- 局部内部类如同局部变量一样，有作用域
- 局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法

举例：

```java
/**
 * ClassName: TestLocalInner
 * @Author 尚硅谷-宋红康
 * @Create 17:19
 * @Version 1.0
 */
public class TestLocalInner {
    public static void main(String[] args) {
        Outer.outMethod();
        System.out.println("-------------------");

        Outer out = new Outer();
        out.outTest();
        System.out.println("-------------------");

        Runner runner = Outer.getRunner();
        runner.run();

    }
}
class Outer{

    public static void outMethod(){
        System.out.println("Outer.outMethod");
        final String c = "局部变量c";
        class Inner{
            public void inMethod(){
                System.out.println("Inner.inMethod");
                System.out.println(c);
            }
        }

        Inner in = new Inner();
        in.inMethod();
    }

    public void outTest(){
        class Inner{
            public void inMethod1(){
                System.out.println("Inner.inMethod1");
            }
        }

        Inner in = new Inner();
        in.inMethod1();
    }

    public static Runner getRunner(){
        class LocalRunner implements Runner{
            @Override
            public void run() {
                System.out.println("LocalRunner.run");
            }
        }
        return new LocalRunner();
    }

}
interface Runner{
    void run();
}
```

#### 匿名内部类
因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题。
```java
new 父类([实参列表]){
    重写方法...
}
```
```java
new 父接口(){
    重写方法...
}
```
举例1：使用匿名内部类的对象直接调用方法：
```java
interface A{
	void a();
}
public class Test{
    public static void main(String[] args){
    	new A(){
			@Override
			public void a() {
				System.out.println("aaaa");
			}
    	}.a();
    }
}
```
举例2：通过父类或父接口的变量多态引用匿名内部类的对象
```java
interface A{
	void a();
}
public class Test{
    public static void main(String[] args){
    	A obj = new A(){
			@Override
			public void a() {
				System.out.println("aaaa");
			}
    	};
    	obj.a();
    }
}
```
举例3：匿名内部类的对象作为实参
```java
interface A{
	void method();
}
public class Test{
    public static void test(A a){
    	a.method();
    }
    
    public static void main(String[] args){
    	test(new A(){

			@Override
			public void method() {
				System.out.println("aaaa");
			}
    	});
    }   
}
```
## 枚举
###  概述

- 枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。
- 枚举类的例子举不胜举：
   - 星期：Monday(星期一)......Sunday(星期天)
   - 性别：Man(男)、Woman(女)
   - 月份：January(1月)......December(12月)
   - 季节：Spring(春节)......Winter(冬天)
   - 三原色：red(红色)、green(绿色)、blue(蓝色)
   - 支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)
   - 就职状态：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职)
   - 订单状态：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消）
   - 线程状态：创建、就绪、运行、阻塞、死亡
- **若枚举只有一个对象, 则可以作为一种单例模式的实现方式。**
- 枚举类的实现：
   - 在JDK5.0 之前，需要程序员自定义枚举类型。
   - 在JDK5.0 之后，Java支持enum关键字来快速定义枚举类型。
### 定义枚举类(JDK5.0之前)
在JDK5.0 之前如何声明枚举类呢？

- 私有化类的构造器，保证不能在类的外部创建其对象
- 在类的内部创建枚举类的实例。声明为：public static final ，对外暴露这些常量对象
- 对象如果有实例变量，应该声明为private final（建议，不是必须），并在构造器中初始化

示例代码：
```java
class Season{
    private final String SEASONNAME;//季节的名称
    private final String SEASONDESC;//季节的描述
    private Season(String seasonName,String seasonDesc){
        this.SEASONNAME = seasonName;
        this.SEASONDESC = seasonDesc;
    }
    public static final Season SPRING = new Season("春天", "春暖花开");
    public static final Season SUMMER = new Season("夏天", "夏日炎炎");
    public static final Season AUTUMN = new Season("秋天", "秋高气爽");
    public static final Season WINTER = new Season("冬天", "白雪皑皑");

    @Override
    public String toString() {
        return "Season{" +
                "SEASONNAME='" + SEASONNAME + '\'' +
                ", SEASONDESC='" + SEASONDESC + '\'' +
                '}';
    }
}
class SeasonTest{
    public static void main(String[] args) {
        System.out.println(Season.AUTUMN);
    }
}
```
### 定义枚举类(JDK5.0之后)
#### enum关键字声明枚举
```java
【修饰符】 enum 枚举类名{
    常量对象列表
}

【修饰符】 enum 枚举类名{
    常量对象列表;
    
    对象的实例变量列表;
}
```
举例：
```java
package com.atguigu.enumeration;

public enum Week {
    MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;
}
```
```java
public class TestEnum {
	public static void main(String[] args) {
		Season spring = Season.SPRING;
		System.out.println(spring);
	}
}
```
#### enum方式定义的要求和特点

- 枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。
- 列出的实例系统会自动添加 public static final 修饰。
- 如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。
- 编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数
- 如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。
- 枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。
- JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。

举例2：
```java
public enum SeasonEnum {
    SPRING("春天","春风又绿江南岸"),
    SUMMER("夏天","映日荷花别样红"),
    AUTUMN("秋天","秋水共长天一色"),
    WINTER("冬天","窗含西岭千秋雪");

    private final String seasonName;
    private final String seasonDesc;
    
    private SeasonEnum(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }
    public String getSeasonName() {
        return seasonName;
    }
    public String getSeasonDesc() {
        return seasonDesc;
    }
}
```
经验之谈：
开发中，当需要定义一组常量时，强烈建议使用枚举类。
### enum中常用的方法
```java
String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！
    
static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法
    
static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。
    
String name():得到当前枚举常量的名称。建议优先使用toString()。
    
int ordinal():返回当前枚举常量的次序号，默认从0开始
```
```java
package com.atguigu.enumeration;

import java.util.Scanner;

public class TestEnumMethod {
    public static void main(String[] args) {
        //values()
        Week[] values = Week.values();
        for (int i = 0; i < values.length; i++) {
            //ordinal()、name()
            System.out.println((values[i].ordinal()+1) + "->" + values[i].name());
        }
        System.out.println("------------------------");

        Scanner input = new Scanner(System.in);
        System.out.print("请输入星期值：");
        int weekValue = input.nextInt();
        Week week = values[weekValue-1];
        //toString()
        System.out.println(week);

        System.out.print("请输入星期名：");
        String weekName = input.next();
        //valueOf()
        week = Week.valueOf(weekName);
        System.out.println(week);

        input.close();
    }
}
```
### 实现接口枚举类

- 和普通 Java 类一样，枚举类可以实现一个或多个接口
- 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。
- 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法

语法：
```java
//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！
enum A implements 接口1，接口2{
	//抽象方法的实现
}

//2、如果枚举类的常量可以继续重写抽象方法!
enum A implements 接口1，接口2{
    常量名1(参数){
        //抽象方法的实现或重写
    },
    常量名2(参数){
        //抽象方法的实现或重写
    },
    //...
}
```
举例
```java
interface Info{
	void show();
}

//使用enum关键字定义枚举类
enum Season1 implements Info{
	//1. 创建枚举类中的对象,声明在enum枚举类的首位
	SPRING("春天","春暖花开"){
		public void show(){
			System.out.println("春天在哪里？");
		}
	},
	SUMMER("夏天","夏日炎炎"){
		public void show(){
			System.out.println("宁静的夏天");
		}
	},
	AUTUMN("秋天","秋高气爽"){
		public void show(){
			System.out.println("秋天是用来分手的季节");
		}
	},
	WINTER("冬天","白雪皑皑"){
		public void show(){
			System.out.println("2002年的第一场雪");
		}
	};
	
	//2. 声明每个对象拥有的属性:private final修饰
	private final String SEASON_NAME;
	private final String SEASON_DESC;
	
	//3. 私有化类的构造器
	private Season1(String seasonName,String seasonDesc){
		this.SEASON_NAME = seasonName;
		this.SEASON_DESC = seasonDesc;
	}
	
	public String getSEASON_NAME() {
		return SEASON_NAME;
	}

	public String getSEASON_DESC() {
		return SEASON_DESC;
	}
}
```
## 注解
### 概述
注解（Annotation）是从JDK5.0开始引入，以“@注解名”在代码中存在。例如：
```java
@Override
@Deprecated
@SuppressWarnings(value=”unchecked”)
```
Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name=value” 对中。
注解可以在类编译、运行时进行加载，体现不同的功能。
### 注解与注释
注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解，不同于单行注释和多行注释。
● 对于单行注释和多行注释是给程序员看的。
● 而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。
### 注解的重要性
在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。
未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。
### 常见的Annotation 的作用
生成文档相关的注释
```java
@author 标明开发该类模块的作者，多个作者之间使用,分割
@version 标明该类模块的版本
@see 参考转向，也就是相关主题
@since 从哪个版本开始增加的
@param 对方法中某参数的说明，如果没有参数就不能写
@return 对方法返回值的说明，如果方法的返回值类型是void就不能写
@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写
```
**示例2：在编译时进行格式检查(JDK内置的三个基本注解)**
@Override: 限定重写父类方法，该注解只能用于方法
@Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择
@SuppressWarnings: 抑制编译器警告
```java
package com.annotation.javadoc;
 
public class AnnotationTest{
 
	public static void main(String[] args) {
		@SuppressWarnings("unused")
		int a = 10;
	}
	@Deprecated
	public void print(){
		System.out.println("过时的方法");
	}
 
	@Override
	public String toString() {
		return "重写的toString方法()";
	}
}
```
**示例3：跟踪代码依赖性，实现替代配置文件功能**

- Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。
```java
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    
    protected void doGet(HttpServletRequest request, HttpServletResponse response) { }
    
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        doGet(request, response);
	}  
}
```

```java
<servlet>
    <servlet-name>LoginServlet</servlet-name>
    <servlet-class>com.servlet.LoginServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>LoginServlet</servlet-name>
    <url-pattern>/login</url-pattern>
  </servlet-mapping>
```
```java
@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)
public void buyBook(String username, String isbn) {
	//1.查询书的单价
    int price = bookShopDao.findBookPriceByIsbn(isbn);
    //2. 更新库存
    bookShopDao.updateBookStock(isbn);	
    //3. 更新用户的余额
    bookShopDao.updateUserAccount(username, price);
}
```
```java
<!-- 配置事务属性 -->
<tx:advice transaction-manager="dataSourceTransactionManager" id="txAdvice">
       <tx:attributes>
       <!-- 配置每个方法使用的事务属性 -->
       <tx:method name="buyBook" propagation="REQUIRES_NEW" 
	 isolation="READ_COMMITTED"  read-only="false"  timeout="3" />
       </tx:attributes>
</tx:advice>
```
### 三个最基本的注解
#### 10.3.1 [@Override](/Override )

- 用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！
- 只能标记在方法上。
- 它会被编译器程序读取。
#### 10.3.2 [@Deprecated](/Deprecated )

- 用于表示被标记的数据已经过时，不推荐使用。
- 可以用于修饰 属性、方法、构造、类、包、局部变量、参数。
- 它会被编译器程序读取。
#### 10.3.3 [@SuppressWarnings](/SuppressWarnings )

- 抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息
- 可以用于修饰类、属性、方法、构造、局部变量、参数
- 它会被编译器程序读取。
- 可以指定的警告类型有（了解）
   - all，抑制所有警告
   - unchecked，抑制与未检查的作业相关的警告
   - unused，抑制与未用的程式码及停用的程式码相关的警告
   - deprecation，抑制与淘汰的相关警告
   - nls，抑制与非 nls 字串文字相关的警告
   - null，抑制与空值分析相关的警告
   - rawtypes，抑制与使用 raw 类型相关的警告
   - static-access，抑制与静态存取不正确相关的警告
   - static-method，抑制与可能宣告为 static 的方法相关的警告
   - super，抑制与置换方法相关但不含 super 呼叫的警告
### 元注解
JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。
（1）**@Target：**用于描述注解的使用范围

- 可以通过枚举类型ElementType的10个常量对象来指定
- TYPE，METHOD，CONSTRUCTOR，PACKAGE.....

（2）**@Retention：**用于描述注解的生命周期

- 可以通过枚举类型RetentionPolicy的3个常量对象来指定
- SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）
- 唯有RUNTIME阶段才能被反射读取到。

（3）[@Documented](/Documented )：表明这个注解应该被 javadoc工具记录。
（4）**@Inherited：**允许子类继承父类中的注解
示例代码：
```java
package java.lang;

import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```
```java
package java.lang;

import java.lang.annotation.*;
import static java.lang.annotation.ElementType.*;

@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```
```java
package java.lang;

import java.lang.annotation.*;
import static java.lang.annotation.ElementType.*;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
```
### 自定义注解的使用
一个完整的注解应该包含三个部分：
（1）声明
（2）使用
（3）读取
#### 声明自定义注解
```java
【元注解】
【修饰符】 @interface 注解名{
    【成员列表】
}
```

- 自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。
- Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组
- 可以使用 default 关键字为抽象方法指定默认返回值
- 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value=”，所以如果注解只有一个抽象方法成员，建议使用方法名value。
```java
package com.atguigu.annotation;

import java.lang.annotation.*;

@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {
    String value();
}
```
```java
package com.atguigu.annotation;

import java.lang.annotation.*;

@Inherited
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    String columnName();
    String columnType();
}
```
#### 使用自定义注解
```java
package com.atguigu.annotation;

@Table("t_stu")
public class Student {
    @Column(columnName = "sid",columnType = "int")
    private int id;
    @Column(columnName = "sname",columnType = "varchar(20)")
    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
```
#### 读取和处理自定义注解
自定义注解必须配上注解的信息处理流程才有意义。
我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。
### 注解与反射
注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解
```vue
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {}
```
然后通过 getAnnotation() 方法来获取 Annotation 对象
```vue
 public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {}
```
或者是 getAnnotations() 方法。
```vue
public Annotation[] getAnnotations() {}
```
前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。

如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如
```java
@TestAnnotation()
public class Test {
    public static void main(String[] args) {
        boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);
        if ( hasAnnotation ) {
            TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);
            System.out.println("id:"+testAnnotation.id());
            System.out.println("msg:"+testAnnotation.msg());
        }
    }
}
```
程序的运行结果是：
```
id:-1
msg:
```
这个正是 TestAnnotation 中 id 和 msg 的默认值。
上面的例子中，只是检阅出了注解在类上的注解，其实属性、方法上的注解照样是可以的。同样还是要假手于反射。
```java
@TestAnnotation(msg="hello")
public class Test {
    @Check(value="hi")
    int a;
    @Perform
    public void testMethod(){}
    @SuppressWarnings("deprecation")
    public void test1(){
        Hero hero = new Hero();
        hero.say();
        hero.speak();
    }
    public static void main(String[] args) {
        boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);
        if ( hasAnnotation ) {
            TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);
            //获取类的注解
            System.out.println("id:"+testAnnotation.id());
            System.out.println("msg:"+testAnnotation.msg());
        }
        try {
            Field a = Test.class.getDeclaredField("a");
            a.setAccessible(true);
            //获取一个成员变量上的注解
            Check check = a.getAnnotation(Check.class);
            if ( check != null ) {
                System.out.println("check value:"+check.value());
            }
            Method testMethod = Test.class.getDeclaredMethod("testMethod");
            if ( testMethod != null ) {
                // 获取方法中的注解
                Annotation[] ans = testMethod.getAnnotations();
                for( int i = 0;i < ans.length;i++) {
                    System.out.println("method testMethod annotation:"+ans[i].annotationType().getSimpleName());
                }
            }
        } catch (NoSuchFieldException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            System.out.println(e.getMessage());
        } catch (SecurityException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            System.out.println(e.getMessage());
        } catch (NoSuchMethodException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            System.out.println(e.getMessage());
        }
    }
}

```
它们的结果如下：
```java

id:-1
msg:hello
check value:hi
method testMethod annotation:Perform
```
需要注意的是，如果一个注解要在运行时被成功提取，那么 @Retention(RetentionPolicy.RUNTIME) 是必须的。
## 包装类
### 为什么需要包装类
因为8种基本数据类型不够用。
有这样的需求：调用doSome()方法的时候需要传一个数字进去。
但是数字属于基本数据类型，而doSome()方法参数的类型是Object
可见doSome()方法无法接收基本数据类型的数字。那怎么办呢?可以传一个数字
八种包装类中其中6个都是数字对应的包装类，他们的父类都是Number,可以先研究一下
Number是一个抽象类,无法实例化对象。
Number类中有这样的方法:
byte byteValue() 以byte形式返回指定的数值。
abstract doublE doubleValue()以double形式返回指定的数值。
abstract float floatValue()以 float形式返回指定的数值。
abstract int intValue()以 int形式返回指定的数值。
abstrac long longValue()以 long形式返回指定的数值。
short shortValue()以 short形式返回指定的数值。
这些方法其实所有的数字包装类的子类都有，这些方法是负责拆箱的。
### 有哪些包装类
Java针对八种基本数据类型定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710314516798-434324fb-9358-412d-b8e0-6e65dd8dfad9.png#averageHue=%23a4c892&clientId=u1ffc2fe9-b811-4&from=paste&height=362&id=u61a18e8c&originHeight=449&originWidth=865&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=73914&status=done&style=none&taskId=u118ea1e6-8fa2-4a1a-91f6-4371b3b4789&title=&width=697.8151036810641)
	1.1、什么是自动装箱和自动拆箱，代码怎么写？
		Integer x = 100; // x里面并不是保存100，保存的是100这个对象的内存地址。
		Integer y = 100;
		System.out.println(x == y); // true
		Integer x = 128;
		Integer y = 128;
		System.out.println(x == y); // false
	1.2、Integer类常用方法。
		Integer.valueOf()
		Integer.parseInt("123")
		Integer.parseInt("中文") : NumberFormatException
	1.3、Integer String int三种类型互相转换。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710314571570-b1c704d2-628f-49f6-8a4f-06f4ec28e0c2.png#averageHue=%23ccddba&clientId=u1ffc2fe9-b811-4&from=paste&height=268&id=ubb6aebd1&originHeight=332&originWidth=560&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=23651&status=done&style=none&taskId=u647b566b-8efe-4914-95d0-e6c76e0ed54&title=&width=451.7646914004577)
java中为了提高程序的执行效率，将-128到127之间的所有包装类提前创建好，放到了方法区的常量池中，目的是这个区间的数字不需要再new对象，直接从整形常量池中取出来。
### 自定义包装类型
```java
public class MyInteger {
    int value;

    public MyInteger() {
    }

    public MyInteger(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return String.valueOf(value);
    }
}
```
### 包装类与基本数据类型间的转换
#### 装箱
**装箱：把基本数据类型转为包装类对象**

> 转为包装类的对象，是为了使用专门为对象设计的API和特性


基本数值---->包装对象
```java
Integer obj1 = new Integer(4);//使用构造函数函数
Float f = new Float(“4.56”);
Long l = new Long(“asdf”);  //NumberFormatException

Integer obj2 = Integer.valueOf(4);//使用包装类中的valueOf方法
```
#### 拆箱

**拆箱：把包装类对象拆为基本数据类型**

> 转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等


包装对象---->基本数值

```java
Integer obj = new Integer(4);
int num1 = obj.intValue();
```

**自动装箱与拆箱：**

由于我们经常要做基本类型与包装类之间的转换，从`JDK5.0`开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。
```

> 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。


```java
Integer i = 1;
Double d = 1;//错误的，1是int类型
```

### 基本数据类型、包装类与字符串间的转换

**（1）基本数据类型转为字符串**

**方式1：**调用字符串重载的valueOf()方法

```java
int a = 10;
//String str = a;//错误的

String str = String.valueOf(a);
```

**方式2：**更直接的方式

```java
int a = 10;

String str = a + "";
```

**（2）字符串转为基本数据类型**

**方式1：**除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型，例如：

- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。
- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。
- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。

**方式2：**字符串转为包装类，然后可以自动拆箱为基本数据类型

- `public static Integer valueOf(String s)`：将字符串参数转换为对应的Integer包装类，然后可以自动拆箱为int基本类型
- `public static Long valueOf(String s)`：将字符串参数转换为对应的Long包装类，然后可以自动拆箱为long基本类型
- `public static Double valueOf(String s)`：将字符串参数转换为对应的Double包装类，然后可以自动拆箱为double基本类型

注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。

**方式3：**通过包装类的构造器实现

```java
int a = Integer.parseInt("整数的字符串");
double d = Double.parseDouble("小数的字符串");
boolean b = Boolean.parseBoolean("true或false");

int a = Integer.valueOf("整数的字符串");
double d = Double.valueOf("小数的字符串");
boolean b = Boolean.valueOf("true或false");

int i = new Integer(“12”);
```

其他方式小结：

![](images/image-20220813012801907.png#id=sb6Fe&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710315009064-443a8152-8b7e-42fb-936e-bfdb74d0b5f7.png#averageHue=%23f8f4f4&clientId=u1ffc2fe9-b811-4&from=paste&height=484&id=u93d44afa&originHeight=600&originWidth=1186&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=164337&status=done&style=none&taskId=u68da3d29-489f-4774-992d-93300da9896&title=&width=956.7730785731122)
### 包装类的其它API
#### 数据类型的最大最小值
```java
Integer.MAX_VALUE和Integer.MIN_VALUE
    
Long.MAX_VALUE和Long.MIN_VALUE
    
Double.MAX_VALUE和Double.MIN_VALUE
```
#### 字符转大小写
```java
Character.toUpperCase('x');

Character.toLowerCase('X');
```
#### 整数转进制
```java
Integer.toBinaryString(int i) 
    
Integer.toHexString(int i)
    
Integer.toOctalString(int i)
```
#### 比较的方法
```java
Integer.toBinaryString(int i) 
    
Integer.toHexString(int i)
    
Integer.toOctalString(int i)
```
### 包装类对象的特点
#### 包装类缓冲对象
| 包装类 | 缓存对象 |
| --- | --- |
| Byte | -128~127 |
| Short | -128~127 |
| Integer | -128~127 |
| Long | -128~127 |
| Float | 没有 |
| Double | 没有 |
| Character | 0~127 |
| Boolean | true和false |

```java
Integer a = 1;
Integer b = 1;
System.out.println(a == b);//true

Integer i = 128;
Integer j = 128;
System.out.println(i == j);//false

Integer m = new Integer(1);//新new的在堆中
Integer n = 1;//这个用的是缓冲的常量对象，在方法区
System.out.println(m == n);//false

Integer x = new Integer(1);//新new的在堆中
Integer y = new Integer(1);//另一个新new的在堆中
System.out.println(x == y);//false
```
```java
Double d1 = 1.0;
Double d2 = 1.0;
System.out.println(d1==d2);//false 比较地址，没有缓存对象，每一个都是新new的
```
#### 类型转换问题
```java
Integer i = 1000;
double j = 1000;
System.out.println(i==j);//true  会先将i自动拆箱为int，然后根据基本数据类型“自动类型转换”规则，转为double比较
```
```java
Integer i = 1000;
int j = 1000;
System.out.println(i==j);//true 会自动拆箱，按照基本数据类型进行比较
```
```java
Integer i = 1;
Double d = 1.0
System.out.println(i==d);//编译报错
```
#### 包装类对象不可变
```java
    public class TestExam {
	public static void main(String[] args) {
		int i = 1;
		Integer j = new Integer(2);
		Circle c = new Circle();
		change(i,j,c);
		System.out.println("i = " + i);//1
		System.out.println("j = " + j);//2
		System.out.println("c.radius = " + c.radius);//10.0
	}
	
	/*
	 * 方法的参数传递机制：
	 * （1）基本数据类型：形参的修改完全不影响实参
	 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值
	 * 这类Integer等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了
	 */
	public static void change(int a ,Integer b,Circle c ){
		a += 10;
//		b += 10;//等价于  b = new Integer(b+10);
		c.radius += 10;
		/*c = new Circle();
		c.radius+=10;*/
	}
}
class Circle{
	double radius;
}
```

