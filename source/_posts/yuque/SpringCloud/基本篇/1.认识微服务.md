---
title: 1.认识微服务
urlname: springcloud01
date: '2024-03-14 14:55:27'
updated: '2024-03-28 16:24:06'
cover: 'https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399319282-ad9cb403-1a3a-43a4-a7a6-d1158cc120a2.png'
description: 1.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？1.0.学习目标了解微服务架构的优缺点1.1.单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。单体架构的优缺点如下：优点：架构简单...
---
# 1.认识微服务

随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？

## 1.0.学习目标

了解微服务架构的优缺点

## 1.1.单体架构

**单体架构**：将业务的所有功能集中在一个项目中开发，打成一个包部署。

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/f157fd7db76249db77879ea3f2e2de06.png)

单体架构的优缺点如下：

**优点：**

- 架构简单
- 部署成本低

**缺点：**

- 耦合度高（维护困难、升级困难）

## 1.2.分布式架构

**分布式架构**：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/374e2a6dbec647b762edba1a23aa8f26.png)

分布式架构的优缺点：

**优点：**

- 降低服务耦合
- 有利于服务升级和拓展

**缺点：**

- 服务调用关系错综复杂

分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：

- 服务拆分的粒度如何界定？
- 服务之间如何调用？
- 服务的调用关系如何管理？

人们需要制定一套行之有效的标准来约束分布式架构。

## 1.3.微服务

微服务的架构特征：

- 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责
- 自治：团队独立、技术独立、数据独立，独立部署和交付
- 面向服务：服务提供统一标准的接口，与语言和技术无关
- 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/0c43e29a57d19c1327daafd493c3f05e.png)

微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。

因此，可以认为**微服务**是一种经过良好架构设计的**分布式架构方案** 。

但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。

其中在Java领域最引人注目的就是SpringCloud提供的方案了。

## 1.4.SpringCloud

SpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。

SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。

其中常见的组件包括：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/16735e1b567b5ae37d8747ae2ed607ff.png)

另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/f66d3b07599859b12ecb2aec64d27323.png)

我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。

## 1.5.总结

-  单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统 
-  分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝 
-  微服务：一种良好的分布式架构方案
①优点：拆分粒度更小、服务更独立、耦合度更低
②缺点：架构非常复杂，运维、监控、部署难度提高 
-  SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件 

# 2.服务拆分和远程调用

任何分布式架构都离不开服务的拆分，微服务也是一样。

## 2.1.服务拆分原则

这里我总结了微服务拆分时的几个原则：

- 不同微服务，不要重复开发相同业务
- 微服务数据独立，不要访问其它微服务的数据库
- 微服务可以将自己的业务暴露为接口，供其它微服务调用

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/f6a68849c2e7c17e1e0f33b4e8b195c8.png)

## 2.2.服务拆分示例

以课前资料中的微服务cloud-demo为例，其结构如下：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/7fe2e1bc0e0f1b41797e9a60cfafd81c.png)

cloud-demo：父工程，管理依赖

- order-service：订单微服务，负责订单相关业务
- user-service：用户微服务，负责用户相关业务

要求：

- 订单微服务和用户微服务都必须有各自的数据库，相互独立
- 订单服务和用户服务都对外暴露Restful的接口
- 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库

### 2.2.1.导入Sql语句

首先，将课前资料提供的`cloud-order.sql`和`cloud-user.sql`导入到mysql中：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/7aa1ab89de225d00758f68f4bbb6cef1.png)

cloud-user表中初始数据如下：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/22cd321748aa91a0465d72c76eca8c47.png)

cloud-order表中初始数据如下：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/d50cc02c2e4acacfa8d4b05765eea08f.png)

cloud-order表中持有cloud-user表中的id字段。

### 2.2.2.导入demo工程

用IDEA导入课前资料提供的Demo：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/ae15a842e18dce6c974f6b0cba0d6b6f.png)

项目结构如下：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/ec7950f79a693e6423c24b67a7d16c4f.png)

导入后，会在IDEA右下角出现弹窗：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/97b0fc40b08e00ab4106c9b68ab62267.png)

点击弹窗，然后按下图选择：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/0dd0a0c8412af26cd41d4701a9e6c0ea.png)

会出现这样的菜单：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/355d3fc498319e409423f2897d585df3.png)

配置下项目使用的JDK：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/3261c45f72f23fa9482a5b9073bfb4c3.png)

## 2.3.实现远程调用案例

在order-service服务中，有一个根据id查询订单的接口：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/fc370520ef7f748f5524f89a88682ae0.png)

根据id查询订单，返回值是Order对象，如图：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/7f2a7f5925a8b4412f30034e61f1cda3.png)

其中的user为null

在user-service中有一个根据id查询用户的接口：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/34c7ce7961318335d959a7b2bd3cebc7.png)

查询的结果如图：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/a74fb50a91b3e4a35ba2670bc6f5fb6b.png)

### 2.3.1.案例需求：

修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/479d244e57812afae1841d9dc43f0834.png)

因此，我们需要在order-service中 向user-service发起一个http的请求，调用http://localhost:8081/user/{userId}这个接口。

大概的步骤是这样的：

- 注册一个RestTemplate的实例到Spring容器
- 修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User
- 将查询的User填充到Order对象，一起返回

### 2.3.2.注册RestTemplate

首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：

```java
package cn.itcast.order;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@MapperScan("cn.itcast.order.mapper")
@SpringBootApplication
public class OrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

### 2.3.3.实现远程调用

修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/93f3da3a6167b381e7be4b147d371e38.png)

## 2.4.提供者与消费者

在服务调用关系中，会有两个不同的角色：

**服务提供者**：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）

**服务消费者**：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）

![](https://raw.githubusercontent.com/choodsire666/blog-img/main/25102cd570d9e542307f7af37b399231.png)

但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。

如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？

- 对于A调用B的业务而言：A是服务消费者，B是服务提供者
- 对于B调用C的业务而言：B是服务消费者，C是服务提供者

因此，服务B既可以是服务提供者，也可以是服务消费者。

# 
