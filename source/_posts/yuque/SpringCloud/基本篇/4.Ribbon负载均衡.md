---
title: 4.Ribbon负载均衡
urlname: fq0g987sh1b1zndz
date: '2024-03-14 15:00:04'
updated: '2024-03-19 17:53:01'
cover: 'https://raw.githubusercontent.com/choodsire666/blog-img/main/4.Ribbon负载均衡/99bdc624b44c70870126962ad2f40f11.png'
description: '4.Ribbon负载均衡上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？4.1.负载均衡原理SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。那么我们发出的请求明明是http://userservice/user/...'
---
# 4.Ribbon负载均衡

上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？

## 4.1.负载均衡原理

SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399323695-3e5165cd-0c4a-461e-b464-439c1563aee8.png#averageHue=%23f8f2f2&id=Fkb8E&originHeight=529&originWidth=1496&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

那么我们发出的请求明明是http://userservice/user/1，怎么变成了http://localhost:8081的呢？

## 4.2.源码跟踪

为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。

显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是`LoadBalancerInterceptor`，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。

我们进行源码跟踪：

### 1）LoadBalancerIntercepor

![](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399323802-84547a31-e404-4a73-8422-d39c47392e84.png#averageHue=%233f3d3c&id=i4RpT&originHeight=435&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：

- `request.getURI()`：获取请求uri，本例中就是 [http://user-service/user/8](http://user-service/user/8)
- `originalUri.getHost()`：获取uri路径的主机名，其实就是服务id，`user-service`
- `this.loadBalancer.execute()`：处理服务id，和用户请求。

### 2）LoadBalancerClient

继续跟入execute方法：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710399988064-6b8d0f8e-ce93-4eb0-9df6-4c318110e33c.png#averageHue=%23444342&clientId=u1ba7c803-b283-4&from=paste&height=265&id=u4b98e8e0&originHeight=328&originWidth=1162&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=154170&status=done&style=none&taskId=u37e1f7d2-6e20-4373-af70-52b8b5ca427&title=&width=937.4117346559498)
![](assets/1525620787090.png#id=uK9cg&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

代码是这样的：

- getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。
- getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务

放行后，再次访问并跟踪，发现获取的是8081：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710400003522-9b97c5a5-9ad7-4aae-9416-930b4a0f5797.png#averageHue=%236a583a&clientId=u1ba7c803-b283-4&from=paste&height=136&id=ubc0528a0&originHeight=169&originWidth=881&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=78353&status=done&style=none&taskId=ud9a69f00-502e-4c70-9ab6-bce995832e6&title=&width=710.7226662925058)
果然实现了负载均衡。
### 3）负载均衡策略IRule

在刚才的代码中，可以看到获取服务使通过一个`getServer`方法来做负载均衡:
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710400051602-31575935-ff82-4517-9bf9-b71d6ca94a9b.png#averageHue=%236d593b&clientId=u1ba7c803-b283-4&from=paste&height=136&id=u1362f3cc&originHeight=168&originWidth=895&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=76813&status=done&style=none&taskId=ue2ffeb71-8cc1-4121-9500-32a24dc3efd&title=&width=722.0167835775172)
我们继续跟入：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710400079988-11e19adb-de79-4dc2-9faa-1ada539ab9e2.png#averageHue=%23f5f5f2&clientId=u1ba7c803-b283-4&from=paste&height=227&id=ue55c6eb1&originHeight=282&originWidth=1137&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=98821&status=done&style=none&taskId=u28199ef3-b9b2-4795-b0bd-1269d752f11&title=&width=917.2436680755721)
继续跟踪源码chooseServer方法，发现这么一段代码：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710400092273-bf73f2ae-a81a-4e79-8dfa-01db2eb93d13.png#averageHue=%23363534&clientId=u1ba7c803-b283-4&from=paste&height=394&id=uda0cde62&originHeight=488&originWidth=732&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=91508&status=done&style=none&taskId=ue8827de9-8fce-4bda-be79-ce796e9ecbd&title=&width=590.5209894734554)
我们看看这个rule是谁：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710400105594-10376d20-1403-4d96-946f-6c4bc811b611.png#averageHue=%23403e3d&clientId=u1ba7c803-b283-4&from=paste&height=265&id=u97aaa172&originHeight=329&originWidth=888&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=122350&status=done&style=none&taskId=u45ef7226-8466-4752-aebc-952a4c6eb18&title=&width=716.3697249350115)
这里的rule默认值是一个`RoundRobinRule`，看类的介绍：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710400119790-8628e951-7b22-4917-b801-1b32210da412.png#averageHue=%23403f3f&clientId=u1ba7c803-b283-4&from=paste&height=167&id=u69d99438&originHeight=207&originWidth=868&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46016&status=done&style=none&taskId=uc40abc6b-eebf-4cf3-ab2f-df85ffe17eb&title=&width=700.2352716707095)
这不就是轮询的意思嘛。

到这里，整个负载均衡的流程我们就清楚了。
### 4）总结

SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710400142084-e33c7a23-7a6c-4369-98c5-fb6d0d9e4774.png#averageHue=%23f9f6f6&clientId=u1ba7c803-b283-4&from=paste&height=428&id=ud0f33f95&originHeight=531&originWidth=1186&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=117462&status=done&style=none&taskId=uf40ca8da-bf6e-419c-96e9-a78a9573093&title=&width=956.7730785731122)
基本流程如下：

- 拦截我们的RestTemplate请求http://userservice/user/1
- RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service
- DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表
- eureka返回列表，localhost:8081、localhost:8082
- IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081
- RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到http://localhost:8081/user/1，发起真实请求

## 4.3.负载均衡策略

### 4.3.1.负载均衡策略

负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：

![image.png](https://cdn.nlark.com/yuque/0/2024/png/29688613/1710400210534-fd62372a-e005-4180-9ba0-749413b2cee3.png#averageHue=%23edf4e5&clientId=u1ba7c803-b283-4&from=paste&height=357&id=u8f19cd8c&originHeight=442&originWidth=1184&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=166038&status=done&style=none&taskId=u73de9e7f-1456-49e2-92fd-9318ddb4410&title=&width=955.159633246682)
不同规则的含义如下：

| **内置负载均衡规则类** | **规则描述** |
| --- | --- |
| RoundRobinRule | 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。 |
| AvailabilityFilteringRule | 对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的..ActiveConnectionsLimit属性进行配置。 |
| WeightedResponseTimeRule | 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。 |
| **ZoneAvoidanceRule** | 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。 |
| BestAvailableRule | 忽略那些短路的服务器，并选择并发数较低的服务器。 |
| RandomRule | 随机选择一个可用的服务器。 |
| RetryRule | 重试机制的选择逻辑 |


默认的实现就是ZoneAvoidanceRule，是一种轮询方案

### 4.3.2.自定义负载均衡策略

通过定义IRule实现可以修改负载均衡规则，有两种方式：

1. 代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：
```json
@Bean
public IRule randomRule(){
    return new RandomRule();
}
```

2. 配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：

```yaml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则
```

> **注意**，一般用默认的负载均衡规则，不做修改。

## 4.4.饥饿加载

Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。

而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：

```yaml
ribbon:
  eager-load:
    enabled: true
    clients: userservice
```
